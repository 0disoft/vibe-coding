$ biome check .
.vibe-coding\TOOLS\security-patterns.ts:692:13 lint/style/useTemplate  FIXABLE  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  i Template literals are preferred over string concatenation.
  
    690 â”‚ 	}
    691 â”‚ 
  > 692 â”‚ 	lines.push('\n' + 'â•'.repeat(50));
        â”‚ 	           ^^^^^^^^^^^^^^^^^^^^^
    693 â”‚ 	lines.push(
    694 â”‚ 		`ì´ ${results.length}ê°œ ë³´ì•ˆ ì´ìŠˆ: âŒ ${counts.error} ì˜¤ë¥˜, !ï¿½ ${counts.warning} ê²½ê³ , ğŸ’¡ ${counts.info} ì •ë³´`
  
  i Unsafe fix: Use a template literal.
  
    690 690 â”‚   	}
    691 691 â”‚   
    692     â”‚ - â†’ lines.push('\n'Â·+Â·'â•'.repeat(50));
        692 â”‚ + â†’ lines.push(`\n${'â•'.repeat(50)}`);
    693 693 â”‚   	lines.push(
    694 694 â”‚   		`ì´ ${results.length}ê°œ ë³´ì•ˆ ì´ìŠˆ: âŒ ${counts.error} ì˜¤ë¥˜, !ï¿½ ${counts.warning} ê²½ê³ , ğŸ’¡ ${counts.info} ì •ë³´`
  

.vibe-coding\TOOLS\a11y-ux-patterns.ts:473:3 lint/style/noNonNullAssertion  FIXABLE  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  ! Forbidden non-null assertion.
  
    471 â”‚ 		const rel = relative(basePath, r.file);
    472 â”‚ 		if (!byFile.has(rel)) byFile.set(rel, []);
  > 473 â”‚ 		byFile.get(rel)!.push(r);
        â”‚ 		^^^^^^^^^^^^^^^^
    474 â”‚ 	}
    475 â”‚ 
  
  i Unsafe fix: Replace with optional chain operator ?. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator
  
    471 471 â”‚   		const rel = relative(basePath, r.file);
    472 472 â”‚   		if (!byFile.has(rel)) byFile.set(rel, []);
    473     â”‚ - â†’ â†’ byFile.get(rel)!.push(r);
        473 â”‚ + â†’ â†’ byFile.get(rel)?.push(r);
    474 474 â”‚   	}
    475 475 â”‚   
  

.vibe-coding\TOOLS\a11y-ux-patterns.ts:370:10 lint/correctness/noUnusedVariables  FIXABLE  â”â”â”â”â”â”â”â”â”â”

  ! This function lintBlock is unused.
  
    369 â”‚ // ì¤„ ë‹¨ìœ„ ê²€ì‚¬ (CSS ë“± ê°„ë‹¨í•œ íŒ¨í„´ìš©)
  > 370 â”‚ function lintBlock(
        â”‚          ^^^^^^^^^
    371 â”‚ 	content: string,
    372 â”‚ 	filePath: string,
  
  i Unused variables are often the result of an incomplete refactoring, typos, or other sources of bugs.
  
  i Unsafe fix: If this is intentional, prepend lintBlock with an underscore.
  
    368 368 â”‚   
    369 369 â”‚   // ì¤„ ë‹¨ìœ„ ê²€ì‚¬ (CSS ë“± ê°„ë‹¨í•œ íŒ¨í„´ìš©)
    370     â”‚ - functionÂ·lintBlock(
        370 â”‚ + functionÂ·_lintBlock(
    371 371 â”‚   	content: string,
    372 372 â”‚   	filePath: string,
  

.vibe-coding\TOOLS\a11y-ux-patterns.ts:409:8 lint/correctness/noUnusedVariables  FIXABLE  â”â”â”â”â”â”â”â”â”â”

  ! This variable htmlRules is unused.
  
    407 â”‚ 	const markupRules = RULES.filter((r) => r.scope === 'markup' || r.scope === 'all');
    408 â”‚ 	const styleRules = RULES.filter((r) => r.scope === 'style' || r.scope === 'all');
  > 409 â”‚ 	const htmlRules = RULES.filter((r) => r.scope === 'html' || r.scope === 'all');
        â”‚ 	      ^^^^^^^^^
    410 â”‚ 
    411 â”‚ 	if (isSvelte) {
  
  i Unused variables are often the result of an incomplete refactoring, typos, or other sources of bugs.
  
  i Unsafe fix: If this is intentional, prepend htmlRules with an underscore.
  
    407 407 â”‚   	const markupRules = RULES.filter((r) => r.scope === 'markup' || r.scope === 'all');
    408 408 â”‚   	const styleRules = RULES.filter((r) => r.scope === 'style' || r.scope === 'all');
    409     â”‚ - â†’ constÂ·htmlRulesÂ·=Â·RULES.filter((r)Â·=>Â·r.scopeÂ·===Â·'html'Â·||Â·r.scopeÂ·===Â·'all');
        409 â”‚ + â†’ constÂ·_htmlRulesÂ·=Â·RULES.filter((r)Â·=>Â·r.scopeÂ·===Â·'html'Â·||Â·r.scopeÂ·===Â·'all');
    410 410 â”‚   
    411 411 â”‚   	if (isSvelte) {
  

.vibe-coding\TOOLS\security-patterns.ts:663:3 lint/style/noNonNullAssertion  FIXABLE  â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  ! Forbidden non-null assertion.
  
    661 â”‚ 		const cat = r.rule.category;
    662 â”‚ 		if (!byCategory.has(cat)) byCategory.set(cat, []);
  > 663 â”‚ 		byCategory.get(cat)!.push(r);
        â”‚ 		^^^^^^^^^^^^^^^^^^^^
    664 â”‚ 	}
    665 â”‚ 
  
  i Unsafe fix: Replace with optional chain operator ?. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator
  
    661 661 â”‚   		const cat = r.rule.category;
    662 662 â”‚   		if (!byCategory.has(cat)) byCategory.set(cat, []);
    663     â”‚ - â†’ â†’ byCategory.get(cat)!.push(r);
        663 â”‚ + â†’ â†’ byCategory.get(cat)?.push(r);
    664 664 â”‚   	}
    665 665 â”‚   
  

.vibe-coding\TOOLS\security-patterns.ts:676:4 lint/style/noNonNullAssertion  FIXABLE  â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  ! Forbidden non-null assertion.
  
    674 â”‚ 			const rel = relative(basePath, r.file);
    675 â”‚ 			if (!byFile.has(rel)) byFile.set(rel, []);
  > 676 â”‚ 			byFile.get(rel)!.push(r);
        â”‚ 			^^^^^^^^^^^^^^^^
    677 â”‚ 		}
    678 â”‚ 
  
  i Unsafe fix: Replace with optional chain operator ?. This operator includes runtime checks, so it is safer than the compile-only non-null assertion operator
  
    674 674 â”‚   			const rel = relative(basePath, r.file);
    675 675 â”‚   			if (!byFile.has(rel)) byFile.set(rel, []);
    676     â”‚ - â†’ â†’ â†’ byFile.get(rel)!.push(r);
        676 â”‚ + â†’ â†’ â†’ byFile.get(rel)?.push(r);
    677 677 â”‚   		}
    678 678 â”‚   
  

.vibe-coding\TOOLS\a11y-ux-patterns.ts:269:10 lint/suspicious/noAssignInExpressions â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— The assignment should not be in an expression.
  
    267 â”‚ 	let match: RegExpExecArray | null;
    268 â”‚ 
  > 269 â”‚ 	while ((match = regex.exec(content)) !== null) {
        â”‚ 	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    270 â”‚ 		const tagEndIndex = match.index + match[0].indexOf('>') + 1;
    271 â”‚ 		const beforeContent = content.slice(0, tagEndIndex);
  
  i The use of assignments in expressions is confusing.
    Expressions are often considered as side-effect free.
  

.vibe-coding\TOOLS\a11y-ux-patterns.ts:348:11 lint/suspicious/noAssignInExpressions â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— The assignment should not be in an expression.
  
    346 â”‚ 		let match: RegExpExecArray | null;
    347 â”‚ 
  > 348 â”‚ 		while ((match = regex.exec(cleanContent)) !== null) {
        â”‚ 		        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    349 â”‚ 			const before = cleanContent.slice(0, match.index);
    350 â”‚ 			const lineInBlock = (before.match(/\n/g) || []).length + 1;
  
  i The use of assignments in expressions is confusing.
    Expressions are often considered as side-effect free.
  

.vibe-coding\TOOLS\a11y-ux-patterns.ts:386:12 lint/suspicious/noAssignInExpressions â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— The assignment should not be in an expression.
  
    384 â”‚ 			let match: RegExpExecArray | null;
    385 â”‚ 
  > 386 â”‚ 			while ((match = regex.exec(line)) !== null) {
        â”‚ 			        ^^^^^^^^^^^^^^^^^^^^^^^^
    387 â”‚ 				results.push({
    388 â”‚ 					file: filePath,
  
  i The use of assignments in expressions is confusing.
    Expressions are often considered as side-effect free.
  

.vibe-coding\TOOLS\fix-bold-issues.ts format â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— Formatter would have printed the following content:
  
     26  26 â”‚   
     27  27 â”‚   // ë³¼ë“œ ë’¤ì— CJKê°€ ì˜¤ëŠ” ê²½ìš°ì—ë§Œ ZWS ì‚½ì…
     28     â”‚ - functionÂ·fixBoldBeforeCJK(text:Â·string):Â·{Â·text:Â·string;Â·count:Â·number;Â·}Â·{
         28 â”‚ + functionÂ·fixBoldBeforeCJK(text:Â·string):Â·{Â·text:Â·string;Â·count:Â·numberÂ·}Â·{
     29  29 â”‚   	let count = 0;
     30  30 â”‚   	const result = text.replace(boldEndingWithPunct, (match, _bold, offset) => {
    Â·Â·Â·Â·Â·Â·Â· â”‚ 
     56  56 â”‚   
     57  57 â”‚   // ì¸ë¼ì¸ ì½”ë“œ êµ¬ê°„ì„ í”¼í•´ ë³¼ë“œ êµì •
     58     â”‚ - functionÂ·fixLineOutsideInlineCode(line:Â·string):Â·{Â·line:Â·string;Â·count:Â·number;Â·}Â·{
         58 â”‚ + functionÂ·fixLineOutsideInlineCode(line:Â·string):Â·{Â·line:Â·string;Â·count:Â·numberÂ·}Â·{
     59  59 â”‚   	// ë°±í‹±ìœ¼ë¡œ splití•˜ê³  ì§ìˆ˜ ì¸ë±ìŠ¤(ì½”ë“œ ì™¸ë¶€)ë§Œ ë³€í™˜
     60  60 â”‚   	const parts = line.split('`');
    Â·Â·Â·Â·Â·Â·Â· â”‚ 
     76  76 â”‚   
     77  77 â”‚   // íœìŠ¤ ì½”ë“œë¸”ë¡ê³¼ ì¸ë¼ì¸ ì½”ë“œë¥¼ ê±´ë„ˆë›°ë©° ë§ˆí¬ë‹¤ìš´ êµì •
     78     â”‚ - functionÂ·fixMarkdownKeepingCodeFences(content:Â·string):Â·{Â·content:Â·string;Â·count:Â·number;Â·}Â·{
         78 â”‚ + functionÂ·fixMarkdownKeepingCodeFences(content:Â·string):Â·{Â·content:Â·string;Â·count:Â·numberÂ·}Â·{
     79  79 â”‚   	// ì›ë³¸ ì¤„ë°”ê¿ˆ ìŠ¤íƒ€ì¼ ê°ì§€ (CRLF vs LF)
     80  80 â”‚   	const lineEnding = content.includes('\r\n') ? '\r\n' : '\n';
  

.vibe-coding\TOOLS\lint-patterns.ts format â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— Formatter would have printed the following content:
  
    250 â”‚ â†’ skipLineRanges:Â·Array<{Â·start:Â·number;Â·end:Â·number;Â·}>Â·=Â·[]
        â”‚                                                     -        

.vibe-coding\TOOLS\security-patterns.ts:402:10 lint/suspicious/noAssignInExpressions â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— The assignment should not be in an expression.
  
    400 â”‚ 	let match: RegExpExecArray | null;
    401 â”‚ 
  > 402 â”‚ 	while ((match = regex.exec(content)) !== null) {
        â”‚ 	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    403 â”‚ 		const tagEndIndex = match.index + match[0].indexOf('>') + 1;
    404 â”‚ 		const beforeContent = content.slice(0, tagEndIndex);
  
  i The use of assignments in expressions is confusing.
    Expressions are often considered as side-effect free.
  

.vibe-coding\TOOLS\security-patterns.ts:419:10 lint/suspicious/noAssignInExpressions â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— The assignment should not be in an expression.
  
    417 â”‚ 	let match: RegExpExecArray | null;
    418 â”‚ 
  > 419 â”‚ 	while ((match = regex.exec(content)) !== null) {
        â”‚ 	        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    420 â”‚ 		const tagEndIndex = match.index + match[0].indexOf('>') + 1;
    421 â”‚ 		const beforeContent = content.slice(0, tagEndIndex);
  
  i The use of assignments in expressions is confusing.
    Expressions are often considered as side-effect free.
  

.vibe-coding\TOOLS\security-patterns.ts:501:12 lint/suspicious/noAssignInExpressions â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— The assignment should not be in an expression.
  
    499 â”‚ 			let match: RegExpExecArray | null;
    500 â”‚ 
  > 501 â”‚ 			while ((match = regex.exec(line)) !== null) {
        â”‚ 			        ^^^^^^^^^^^^^^^^^^^^^^^^
    502 â”‚ 				results.push({
    503 â”‚ 					file: filePath,
  
  i The use of assignments in expressions is confusing.
    Expressions are often considered as side-effect free.
  

.vibe-coding\TOOLS\security-patterns.ts:541:10 lint/suspicious/noAssignInExpressions â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— The assignment should not be in an expression.
  
    539 â”‚ 	let m: RegExpExecArray | null;
    540 â”‚ 
  > 541 â”‚ 	while ((m = re.exec(content)) !== null) {
        â”‚ 	        ^^^^^^^^^^^^^^^^^^^^
    542 â”‚ 		const start = m.index;
    543 â”‚ 
  
  i The use of assignments in expressions is confusing.
    Expressions are often considered as side-effect free.
  

Checked 72 files in 248ms. No fixes applied.
Found 9 errors.
Found 5 warnings.
Found 1 info.
check â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

  Ã— Some errors were emitted while running checks.
  

error: script "lint" exited with code 1
