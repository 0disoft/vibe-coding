# Advanced Rate Limiting 구현 코드 (최종)

피드백(정규식 경계, 표준 헤더)이 반영된 최종 코드입니다.

## 1. Rate Limiter 모듈 (개선됨)
**파일명**: `src/lib/server/rate-limiter.ts`

```typescript
import type { RequestEvent } from '@sveltejs/kit';

export interface RateLimitRule {
	name: string;
	pattern: RegExp;
	windowMs: number;
	max: number;
}

interface RateLimitRecord {
	count: number;
	resetTime: number;
	blocked: boolean;
	blockedUntil: number;
}

const storage = new Map<string, RateLimitRecord>();
let lastSweep = Date.now();
const SWEEP_INTERVAL = 60 * 1000;

export function getClientIP(event: RequestEvent): string {
    // ... (IP 추출 로직 동일) ...
	const h = event.request.headers;
	return (
		h.get('cf-connecting-ip') ||
		h.get('x-real-ip') ||
		h.get('x-forwarded-for')?.split(',')[0]?.trim() ||
		event.getClientAddress() ||
		'unknown'
	);
}

// ... (sweep 함수 동일) ...
function sweep(now: number) { /* 생략 */ }

export function checkRateLimit(
	event: RequestEvent,
	rules: RateLimitRule[]
): {
	blocked: boolean;
	retryAfter: number;
	ruleName?: string;
	limit: number;
	remaining: number;
	reset: number;
} {
	// ... (초기화 및 IP 추출) ...
    const now = Date.now();
    sweep(now); // sweep 호출
    const pathname = event.url.pathname;
    const clientIP = getClientIP(event);

	const rule = rules.find((r) => r.pattern.test(pathname));
	
    // Rule 매칭 실패 시 0 리턴
	if (!rule) {
		return { blocked: false, retryAfter: 0, limit: 0, remaining: 0, reset: 0 };
	}

	const identifier = `i:${clientIP}:${rule.name}`;
	let record = storage.get(identifier);

	// 차단 상태 확인
	if (record?.blocked && now < record.blockedUntil) {
		const retryAfter = Math.ceil((record.blockedUntil - now) / 1000);
		return {
			blocked: true,
			retryAfter,
			ruleName: rule.name,
			limit: rule.max,
			remaining: 0,
			reset: Math.ceil(record.blockedUntil / 1000)
		};
	}

	// 기록 갱신 로직 (Limit 헤더 정보 계산 포함)
    const resetTime = record ? record.resetTime : now + rule.windowMs;
    const count = record ? record.count + 1 : 1;
    
    // ... (저장소 업데이트) ...
    // 실제 구현 코드 참조
    
    // 리턴값 구조:
    // { blocked, retryAfter, ruleName, limit, remaining, reset }
    // ...
    // (위 구현 내용 확인)
    return { /* ... */ };
}
```

## 2. 서버 훅 적용 (헤더 추가)
**파일명**: `src/hooks.server.ts`

```typescript
import { checkRateLimit, getClientIP, type RateLimitRule } from '$lib/server/rate-limiter';

const RATE_LIMIT_RULES: RateLimitRule[] = [
	{
		name: 'high-risk',
		// [피드백 반영] 정규식 경계 조건 추가 ((?:/|$))
		pattern: /^\/(auth|login|signup|reset)(?:$|\/)/,
		windowMs: 60 * 1000,
		max: 10
	},
	{
		name: 'default',
		pattern: /.*/,
		windowMs: policy.rateLimit.windowMs,
		max: policy.rateLimit.maxRequests
	}
];

const handleRateLimit: Handle = async ({ event, resolve }) => {
    // ... (guards) ...

	const { blocked, retryAfter, ruleName, limit, remaining, reset } = checkRateLimit(
		event,
		RATE_LIMIT_RULES
	);

    // [피드백 반영] 표준 Rate Limit 헤더 설정 헬퍼
	const setRateLimitHeaders = (headers: Headers) => {
		if (limit > 0) {
			headers.set('X-RateLimit-Limit', String(limit));
			headers.set('X-RateLimit-Remaining', String(remaining));
			headers.set('X-RateLimit-Reset', String(reset));
		}
	};

	if (blocked) {
        // ... (로그 출력) ...
		const response = new Response(render429Html(retryAfter), {
			status: 429,
			headers: {
				'Content-Type': 'text/html; charset=utf-8',
				'Retry-After': String(retryAfter),
				'Cache-Control': 'private, no-store'
			}
		});
        setRateLimitHeaders(response.headers); // 헤더 추가
		return response;
	}

	const response = await resolve(event);
	setRateLimitHeaders(response.headers); // 정상 응답에도 헤더 추가

	return response;
};
```
