# Advanced Rate Limiting 구현 코드 요약

## 1. Rate Limiter 모듈 (신규 생성)
**파일명**: `src/lib/server/rate-limiter.ts`
**설명**: Rate Limit 로직을 중앙화하고, 규칙 기반(`rules`) 매칭과 식별자(`identifier`) 생성을 담당합니다.

```typescript
import type { RequestEvent } from '@sveltejs/kit';

export interface RateLimitRule {
	name: string;
	pattern: RegExp;
	windowMs: number;
	max: number;
}

interface RateLimitRecord {
	count: number;
	resetTime: number;
	blocked: boolean;
	blockedUntil: number;
}

// 인메모리 저장소 (운영 환경에서는 Redis 권장)
const storage = new Map<string, RateLimitRecord>();

let lastSweep = Date.now();
const SWEEP_INTERVAL = 60 * 1000;

// [유틸] 정확한 클라이언트 IP 추출 (Hook에서도 재사용 가능)
export function getClientIP(event: RequestEvent): string {
	const h = event.request.headers;
	return (
		h.get('cf-connecting-ip') ||
		h.get('x-real-ip') ||
		h.get('x-forwarded-for')?.split(',')[0]?.trim() ||
		event.getClientAddress() ||
		'unknown'
	);
}

// 주기적인 메모리 정리
function sweep(now: number) {
	if (now - lastSweep < SWEEP_INTERVAL) return;
	lastSweep = now;
	for (const [key, record] of storage.entries()) {
		if (!record.blocked && now > record.resetTime) {
			storage.delete(key);
		}
	}
}

// [핵심] Rate Limit 검사 함수
export function checkRateLimit(
	event: RequestEvent,
	rules: RateLimitRule[]
): { blocked: boolean; retryAfter: number; ruleName?: string } {
	const now = Date.now();
	sweep(now);

	const { pathname } = event.url;
	const clientIP = getClientIP(event);

	// 1. 경로 패턴에 맞는 규칙 찾기
	const rule = rules.find((r) => r.pattern.test(pathname));
	if (!rule) return { blocked: false, retryAfter: 0 };

	// 2. 식별자 생성 (IP + 규칙명 조합)
	// 추후 UserID가 있으면 `u:{userId}:{rule.name}` 형태로 확장 가능
	const identifier = `i:${clientIP}:${rule.name}`;

	let record = storage.get(identifier);

	// 3. 차단 상태 확인
	if (record?.blocked && now < record.blockedUntil) {
		const retryAfter = Math.ceil((record.blockedUntil - now) / 1000);
		return { blocked: true, retryAfter, ruleName: rule.name };
	}

	// 4. 카운트 로직 (신규 윈도우 또는 기존 카운트 증가)
	if (!record || now >= record.resetTime) {
		storage.set(identifier, {
			count: 1,
			resetTime: now + rule.windowMs,
			blocked: false,
			blockedUntil: 0
		});
	} else {
		record.count++;
		if (record.count > rule.max) {
			// **제한 초과 시 차단**
			const penaltyMs = rule.windowMs;
			record.blocked = true;
			record.blockedUntil = now + penaltyMs;
			record.resetTime = record.blockedUntil;
			record.count = 0;

			const retryAfter = Math.ceil((record.blockedUntil - now) / 1000);
			return { blocked: true, retryAfter, ruleName: rule.name };
		}
	}

	return { blocked: false, retryAfter: 0, ruleName: rule.name };
}
```

## 2. 서버 훅 적용 (수정됨)
**파일명**: `src/hooks.server.ts`
**설명**: 기존 인메모리 로직을 제거하고, 모듈을 호출하도록 변경했습니다. 경로별 규칙(`RATE_LIMIT_RULES`)을 정의했습니다.

```typescript
import { checkRateLimit, getClientIP, type RateLimitRule } from '$lib/server/rate-limiter';

// [설정] Rate Limit 규칙 정의
const RATE_LIMIT_RULES: RateLimitRule[] = [
	{
		name: 'high-risk',
		// 인증 관련 경로는 엄격하게 제한 (10회/분)
		pattern: /^\/(auth|login|signup|reset)/,
		windowMs: 60 * 1000,
		max: 10
	},
	{
		name: 'default',
		// 그 외 경로는 일반 정책 적용 (50회/분 - constants 정책 사용)
		pattern: /.*/,
		windowMs: policy.rateLimit.windowMs,
		max: policy.rateLimit.maxRequests
	}
];

// ... (render429Html, isStaticRequest 등 헬퍼 함수 생략) ...

const handleRateLimit: Handle = async ({ event, resolve }) => {
	// 정적 파일 및 비문서 요청 제외 로직 생략 (기존 유지)
	// ...

	const clientIP = getClientIP(event);
	if (clientIP === 'unknown') return resolve(event); // IP 식별 불가 시 건너뛰기

	// [검사] 모듈 호출
	const { blocked, retryAfter, ruleName } = checkRateLimit(event, RATE_LIMIT_RULES);

	if (blocked) {
		console.warn(
			`[RateLimit] Triggered block for ${clientIP} (ID: ${event.locals.requestId}) on ${event.url.pathname} [Rule: ${ruleName}]. Retry after ${retryAfter}s.`
		);

		return new Response(render429Html(retryAfter), {
			status: 429,
			headers: {
				'Content-Type': 'text/html; charset=utf-8',
				'Retry-After': String(retryAfter),
				'Cache-Control': 'private, no-store'
			}
		});
	}

	return resolve(event);
};
```
