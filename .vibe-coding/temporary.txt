결론부터 말하면
지금 이용약관 페이지 구조도 꽤 잘 짜놨어. “정적 마크다운 → 서버에서 HTML 변환 → `{@html}`로 렌더”라는 흐름이 깔끔하게 정리돼 있고, i18n·SEO·템플릿 치환까지 잘 챙긴 편이야.

거기에 몇 군데만 살짝 다듬으면 “장기적으로도 안 부끄러운 약관 페이지”가 될 것 같다.

---

## 1. +page.svelte 쪽: 전반적으로 괜찮음

좋은 점부터 정리해볼게.

* `PageData`를 타입으로 가져와서 `let { data }: { data: PageData } = $props();` 한 건 나중에 필드 구조 바뀔 때 큰 도움이 된다.
* `<svelte:head>`에서 언어마다 다른 제목/설명을 주는 것도 잘 했고
  특히 `data.lang`을 기준으로 해서, 영어로 폴백된 상황에서는 자동으로 영문 타이틀과 설명을 쓰게 된 점이 자연스럽다.
* 본문을 `article.prose`로 감싸놓은 것도 좋은 선택이다.
  마크다운 기반 약관은 타이포그래피 preset이랑 궁합이 잘 맞으니까.

여기서 더 좋게 만들 수 있는 포인트 몇 개만 짚자.

1. `lang` 속성 추가 추천

문서 전체 `<html lang="…">`도 있겠지만, 약관이 영어 폴백될 수 있으니 `article`에 명시적으로 넣어두면 좋아.

```svelte
<article
  class="prose mx-auto max-w-3xl px-4 py-12 md:px-6 text-sm"
  lang={data.lang}
>
  {@html data.content}
</article>
```

이러면

* 스크린리더가 언어를 정확히 인식하고
* 브라우저의 줄바꿈, 인용부호 스타일 등이 언어에 맞게 동작해.

2. Fallback 표시를 쓸 계획이 있다면

`isFallback`을 서버에서 넘기고 있는데, 아직 쓰지는 않고 있지.
나중에 “요청하신 언어의 약관이 아직 준비되지 않아 영어 버전을 보여드립니다” 같은 배너를 넣고 싶으면, 여기서 한 줄 정도 표시해도 좋다.

```svelte
{#if data.isFallback}
  <p class="mb-4 text-xs text-muted-foreground">
    이 언어로 된 약관이 아직 준비되지 않아 영어 버전을 표시합니다.
  </p>
{/if}
```

지금은 없어도 전혀 문제는 없고, “쓸 수 있는 확장 포인트” 정도로 기억해두면 될 것 같아.

---

## 2. +page.server.ts: 구조 아주 좋고, 몇 군데 미세 튜닝

전체 흐름은 딱 이렇게 되어 있지.

* `import.meta.glob`으로 `/src/content/terms/*.md`를 빌드 타임에 몽땅 읽어온다.
* URL에서 locale 추출해서 해당 언어 마크다운을 찾고, 없으면 영어로 폴백.
* `{{SITE_NAME}}`, `{{EMAIL}}`, `{{CPO_NAME}}`, `{{LAST_UPDATED}}` 같은 토큰을 치환.
* `marked`로 HTML 변환 후 `content`로 반환.

이 구조 자체는 매우 이상적이다.
서버리스에서도 잘 돌아가고, 파일 I/O 없이 번들 안에서 해결되고, 템플릿 치환도 깔끔해.

여기서 체크·개선 포인트를 몇 가지 보자.

### 2-1. `marked` 사용 방식

지금:

```ts
const content = await marked(markdown);
```

동작에는 문제 없는데, `marked` 기본 설정만 쓰는 한 이 부분은 동기 함수라서 그냥 아래처럼 써도 된다.

```ts
const content = marked.parse(markdown);
```

혹은

```ts
const content = marked(markdown);
```

`await`로 감싸도 자바스크립트 레벨에서는 상관없지만
너가 평소에 “단순 연산에는 불필요한 await 쓰지 말자” 원칙을 쓰니까, 여기서는 `parse`로 명확하게 동기 호출을 하는 쪽이 코드를 읽을 때 더 직관적일 거야.

나중에 커스텀 렌더러를 추가해서 진짜 비동기 플러그인을 쓰게 된다면 그때 `await marked.parse`로 바꾸면 되고.

### 2-2. XSS·보안 측면

현재 소스:

* 마크다운 파일은 `/src/content/terms/*.md`에 직접 커밋
* 치환에 쓰는 `site.name`, `site.email`, `policy.cpoName`, `policy.effectiveDate.terms`도 코드 상의 상수

즉, “완전히 너가 통제하는 입력”만 들어오기 때문에
지금 상태에서 XSS 걱정은 사실상 없어.

다만, 나중에 이런 일이 생기면 생각을 다시 해야 한다.

* 관리용 CMS에서 약관 마크다운을 수정한다.
* 비개발자도 마크다운을 넣을 수 있게 한다.
* 마크다운 안에 HTML 블록을 허용한다.

이 순간부터는 `{@html}` + `marked` 조합에 서버 측 Sanitizer를 하나 더 끼우는 걸 진지하게 고려해야 한다.
예를 들어 서버에서만 `DOMPurify` 같은 걸 한 번 더 돌린다든지.

지금은 “정적 md + 코드 상수” 구조라서 그대로 둬도 충분히 안전한 상태라고 봐도 된다.

### 2-3. locale 추출 / 날짜 포맷

이 부분도 설계 잘 됐어.

```ts
new Intl.DateTimeFormat(actualLang, { dateStyle: 'long' }).format(
  new Date(policy.effectiveDate.terms)
);
```

* `actualLang`을 기준으로 날짜를 포맷해서, 영어로 폴백된 경우 “December 9, 2025” 같은 모양으로 바뀌는 것, 자연스럽다.
* 만약 Paraglide에서 `zh-CN`, `pt-BR` 같은 구체적인 태그도 다루고 있다면 그대로 `Intl`에 넘겨도 잘 동작하니까 여기 구조는 문제 없음.

다만 `policy.effectiveDate.terms` 값만 ISO 문자열로 관리해 둔다면, “언제든 다른 형식으로도 뽑을 수 있는 상태”라 유지 보수에 좋다.

### 2-4. prerender 설정 고려

이용약관은 거의 항상 “정적 문서”라서, SvelteKit에 미리 힌트를 알려주면 좋다.

```ts
export const prerender = true;
```

이렇게 해 두면:

* adapter-static이면 빌드 타임에 `/terms`, `/ko/terms` 같은 페이지가 HTML 파일로 뽑힌다.
* 서버 어댑터를 쓰더라도 프리랜더 대상인 경우에는, 요청 시마다 `marked`를 다시 돌릴 필요 없이 이미 준비된 HTML을 바로 보내줄 수 있다.

물론 “항상 최신 정책을 마크다운에서 읽어야 한다” 같은 요구가 없다면, 약관처럼 거의 안 바뀌는 문서는 프리랜더 쪽이 더 맞는 편이지.

### 2-5. fallback 언어 처리 로직

현재 로직:

```ts
const lang = extractLocaleFromUrl(url.href) || 'en';

let markdown = termsFiles[getFilePath(lang)];
let actualLang = lang;

if (!markdown) {
  markdown = termsFiles[getFilePath('en')];
  actualLang = 'en';

  if (!markdown) {
    throw error(500, 'Terms of service content not found');
  }
}
```

이 구조도 좋다.

* 잘못된 언어 코드가 들어오면 그대로 영어로 폴백
* 영어조차 없으면 500을 내면서 “정말로 운영상 문제다”라고 드러낸다.

추가로 생각해볼 수 있는 건 이 정도야.

* 지원하는 언어 리스트를 `const SUPPORTED_TERMS_LOCALES = ['en', 'ko', ...]`처럼 따로 두고
* `extractLocaleFromUrl` 결과가 저 리스트에 없으면, 아예 처음부터 lang을 'en'으로 강제

지금도 크게 문제는 없고, “약관은 영어가 항상 있다”는 전제를 깔 거면 현재 코드로도 충분히 명료하다.

---

## 3. 전체적으로 봤을 때 상태 평가

지금 구성은 이렇게 요약할 수 있을 것 같아.

* 정적 md 파일을 빌드 타임에 읽어서 서버 번들에 포함
* 서버에서 템플릿 치환 + 마크다운 렌더링
* 클라이언트에는 깨끗한 HTML만 전달
* i18n 폴백, 날짜 포맷, SEO 메타까지 모두 포함

실제 서비스 운영 기준으로도 충분히 탄탄한 구조고
여기에

* `marked.parse`로 불필요한 await 제거
* `article lang={data.lang}` 추가
* 필요하다면 `prerender = true` 설정

이 정도만 더해주면 “1인 개발자 인프라”보다는 한 단계 윗급의 구성이 될 거야.
