핵심만 말하면, 이 모달은 “바로 써도 되는 수준”이고 구조도 잘 잡혀 있어요 😎
언어 감지 방식, Paraglide 방어 코드, 모달 닫기 UX까지 전반적으로 균형이 좋음.

그 위에 살짝만 다듬으면 더 단단해질 것들 위주로 정리해볼게.

---

## 1. 언어 감지 로직

좋은 점

* URL 우선
  `currentLang`을 `page.url.pathname`에서 직접 뽑는 구조라, Paraglide 내부 상태보다 항상 “실제 주소창”을 신뢰하는 게 아주 좋음.

  ```ts
  let currentLang = $derived.by(() => {
    const path = page.url.pathname;
    const segment = path.split('/')[1];
    if (availableLanguageTags.includes(segment)) {
      return segment;
    }
    const runtimeLang = (runtime as any).getLocale?.() ?? (runtime as any).languageTag?.();
    return runtimeLang ?? 'en';
  });
  ```

* 런타임 방어 코드
  `availableLocales`, `locales`, `availableLanguageTags`, 없으면 `defaultLocales`로 떨어지는 다단계 fallback도 현실적인 방어 코딩 스타일이라 좋음.

주의하면 좋은 부분

* `availableLanguageTags` 값 형식

  만약 Paraglide 쪽에서 `'en-US'` 같은 태그를 쓰고, URL은 `/en/...` 형식이면

  * `availableLanguageTags.includes(segment)`에서 매치 안 되고
  * `lang === currentLang`에서도 하이라이트가 안 될 수 있어요.

  지금 프로젝트에서 locale을 전부 `'en' | 'ko' | 'ja'`처럼 “언어 코드만” 쓰고 있다면 그대로 두면 되고,
  혹시 나중에 지역코드까지 붙이게 되면:

  * URL도 `/en-US/...`로 맞추거나
  * 비교할 때 `segment.split('-')[0]` 같은 가벼운 정규화 레이어를 하나 넣는 정도를 고려하면 좋음.

---

## 2. 모달/포커스/접근성

좋은 점

* 상태/포커스 관리

  ```ts
  let showLanguageModal = $state(false);
  let modalRef: HTMLDivElement | undefined = $state();
  let buttonRef: HTMLButtonElement | undefined = $state();

  function closeLanguageModal() {
    if (!showLanguageModal) return;
    showLanguageModal = false;
    buttonRef?.focus();
  }
  ```

  * `$state`로 모달 플래그와 ref를 관리하는 패턴은 Svelte 5 runes 모드에 잘 맞음.
  * 닫힐 때마다 `buttonRef?.focus()`로 포커스 복귀하는 것도 접근성 측면에서 모범 답안.

* 바깥 클릭/ESC 처리

  ```ts
  <svelte:window onclick={handleOutsideClick} onkeydown={handleKeyDown} />
  ```

  `handleOutsideClick`에서 버튼/모달 둘 다 아닌 곳을 클릭했을 때만 닫는 조건도 잘 짰고,
  ESC 키로 닫는 것도 체크해서 “언제 닫혀도 버튼으로 포커스 복귀”가 유지되도록 잘 맞춰져 있어요.

조금 손보면 좋은 포인트

* `handleKeyDown`에서 이벤트 전파

  ```ts
  function handleKeyDown(event: KeyboardEvent) {
    if (showLanguageModal && event.key === 'Escape') {
      closeLanguageModal();
    }
  }
  ```

  이 상태도 동작은 하는데, 페이지 상단에서 다른 ESC 핸들러(다른 모달, 단축키 시스템 등)를 붙일 일이 생기면
  같은 ESC에 두 군데가 반응할 수 있어요.

  살짝만 바꾸면 더 안전해짐.

  ```ts
  function handleKeyDown(event: KeyboardEvent) {
    if (!showLanguageModal) return;
    if (event.key === 'Escape') {
      event.stopPropagation(); // 다른 핸들러로 안 올라가게
      closeLanguageModal();
    }
  }
  ```

  지금 당장 필수는 아니지만, “언제든 모달을 더 붙일 수 있는 템플릿”이라는 관점에서 보면 꽤 값어치 있는 한 줄.

---

## 3. 링크 생성과 Paraglide 연동

여기가 가장 중요한 부분인데, 구조 잘 잡혀 있음.

```svelte
{#each availableLanguageTags as lang}
  <a
    href={localizeUrl(page.url.pathname + page.url.search, { locale: lang }).href}
    class="inline-flex h-8 w-full items-center justify-start px-2 rounded-md text-sm transition-colors {lang ===
    currentLang
      ? 'bg-primary text-primary-foreground'
      : 'hover:bg-accent hover:text-accent-foreground'}"
    data-sveltekit-reload
    onclick={closeLanguageModal}
    aria-current={lang === currentLang ? 'page' : undefined}
    hreflang={lang}
  >
    {getLanguageName(lang)}
  </a>
{/each}
```

좋은 점

* `localizeUrl`로 현재 경로 + 쿼리를 유지하면서 locale만 바꾸는 구조라 UX 자연스럽고,
* `data-sveltekit-reload`로 “언어 바뀔 때는 SSR부터 새로 받고 싶다”라는 의도가 드러나 있어서 명확함.
* `aria-current="page"`와 `hreflang`까지 붙여줘서 검색·스크린리더 모두에 친화적.

개선 아이디어 (선택사항)

* class 부분 가독성 살짝 개선

  문자열 안에 삼항을 끼워넣는 지금 방식도 동작은 좋지만, 읽을 때 눈이 한번 꼬여요.
  미리 `const isActive = lang === currentLang;`를 쓰거나 템플릿 리터럴로 정리해주면 나중에 유지보수할 때 편함.

  예를 들면:

  ```svelte
  {#each availableLanguageTags as lang}
    {#key lang}
      {#let isActive = lang === currentLang}
        <a
          href={localizeUrl(page.url.pathname + page.url.search, { locale: lang }).href}
          class={`inline-flex h-8 w-full items-center justify-start px-2 rounded-md text-sm transition-colors ${
            isActive
              ? 'bg-primary text-primary-foreground'
              : 'hover:bg-accent hover:text-accent-foreground'
          }`}
          data-sveltekit-reload
          onclick={closeLanguageModal}
          aria-current={isActive ? 'page' : undefined}
          hreflang={lang}
        >
          {getLanguageName(lang)}
        </a>
      {/let}
    {/key}
  {/each}
  ```

  기능은 완전히 동일하고, 나중에 “현재 언어인 경우 아이콘 하나 더 붙이고 싶다” 같은 요구가 생겨도 `isActive`로 분기만 추가하면 끝.

---

## 4. 언어 이름/태그 매핑

```ts
const languageNames: Record<string, string> = {
  en: 'English',
  ko: '한국어',
  // ...
};

function getLanguageName(code: string): string {
  return languageNames[code] ?? code.toUpperCase();
}
```

* 지원 언어를 “사람이 읽는 이름”으로 맵핑해두고,
  빠진 언어는 `code.toUpperCase()`로 뱉는 식이라 확장성도 좋고 방어도 잘 되어 있음.
* 나중에 관리자용 언어 추가할 때도 `languageNames`만 손보면 되니까, 이 부분도 구조 괜찮아요.

주의할 지점 하나만 덧붙이면

* `availableLanguageTags`가 `'en-US'` 형식이면 `languageNames[code]`가 없어서 `'EN-US'`로 뜨게 되는데,
  이게 의도라면 그대로 두고, “국가별 이름까지 제대로 보여주고 싶다”면 나중에 한 번 더 추상화하는 정도를 생각해볼 수 있음.

---

## 정리

* 지금 코드, “언어 선택 팝오버”로서 기능적으로 매우 잘 짜여 있고
* Paraglide 런타임 변화에 대비한 fallback도 잘 넣었고
* 모달 닫기 UX와 포커스 복귀까지 챙겨서 기본 퀄리티는 이미 높음.

필수로 고쳐야 할 심각한 버그는 안 보이고,
딱 두 가지만 “정말 미세 튜닝” 수준으로 추천할 수 있음.

* ESC 핸들러에서 `event.stopPropagation()` 한 줄 추가
* locale 형식이 `언어코드-only`인지, `언어+지역`인지 프로젝트 레벨에서 한 번만 더 점검

이 두 가지만 확인하거나 보완해 두면, 템플릿으로 재사용해도 크게 건드릴 일 없는 안정적인 컴포넌트라고 봐도 될 것 같아요.

---
