바닐라 HTML에서 진짜 위험한 건 “태그 자체”가 아니라, HTML이 신뢰 경계선을 넘는 순간입니다. 한 번만 섞여도, 화면은 공격자의 무대가 돼요.

아래는 사소한 건 빼고, 사고로 이어지기 쉬운 것만 골랐습니다.

## 1) HTML 인젝션, XSS의 시작점

사용자 입력이 그대로 HTML로 렌더되면, 공격자는 태그를 주입해 화면을 바꾸고 스크립트를 실행하려고 합니다. OWASP는 HTML 인젝션 자체가 세션 탈취나 사용자 가장 같은 결과로 이어질 수 있다고 정리합니다. ([owasp.org][1])

특히 많이 터지는 형태

* 댓글, 프로필, 게시글 같은 사용자 콘텐츠를 “그대로 HTML로 출력”
* 서버 템플릿에서 문자열 합치기로 HTML 만들기
* URL 파라미터를 그대로 페이지에 반영하기. 반사형 XSS의 전형 패턴입니다 ([owasp.org][2])

실전 처방

* 사용자 입력은 기본값을 텍스트로 취급하고, 정말 필요한 경우에만 제한적으로 HTML을 허용하기
* 입력 필터링만으로 끝내지 말기. 우회가 가능하다는 걸 OWASP가 따로 모아놨습니다 ([cheatsheetseries.owasp.org][3])
* 출력 지점 기준으로 인코딩과 이스케이프를 설계하기. 콘텍스트별 방어가 핵심입니다 ([cheatsheetseries.owasp.org][4])

## 2) 속성 컨텍스트 주입, onerror 한 방이면 끝

HTML에서 가장 흔한 사고는 “속성 값”에 사용자 입력을 끼워 넣는 겁니다.

예시로 이런 패턴이 위험합니다

* `<img src="...사용자입력...">`
* `<a href="...사용자입력...">`
* `<div data-x="...사용자입력...">`

공격자는 따옴표를 닫고 새 속성을 추가합니다. 그리고 `onerror`, `onclick` 같은 이벤트 핸들러로 실행을 시도하죠. OWASP DOM XSS 가이드도 속성 컨텍스트는 일반 규칙과 다르며 별도 처리가 필요하다고 강조합니다. ([cheatsheetseries.owasp.org][5])

실전 처방

* 속성에 사용자 입력을 넣어야 한다면 화이트리스트 기반으로 값의 형태를 제한하기
* URL 속성은 프로토콜을 강제하고, `javascript:` 같은 스킴을 원천 차단하기
* 이벤트 핸들러 속성은 사용자 입력과 절대 합치지 않기

## 3) DOM 기반 XSS, HTML만 “있어도” JS가 먹잇감이 된다

바닐라 HTML을 쓴다고 해도, 프런트에서 조금이라도 동적으로 DOM을 만지면 DOM XSS가 생깁니다. 공격자가 조종 가능한 값이 `innerHTML` 같은 싱크로 들어가는 순간이 포인트예요. ([portswigger.net][6])

실전 처방

* 사용자 입력을 DOM에 넣을 때는 `textContent` 중심으로 가기
* HTML이 꼭 필요하면 정화된 결과만 넣기

## 4) CSP를 느슨하게 두면, 인라인 이벤트가 활짝 열린다

CSP는 “이 사이트는 어떤 스크립트를 믿는가”를 선언하는 방패입니다. 중요한 점은 CSP의 `script-src`가 인라인 이벤트 핸들러도 영향을 받는다는 것, 즉 CSP가 제대로 걸려 있으면 `onclick` 같은 인라인 실행을 크게 줄일 수 있습니다. ([MDN 웹 문서][7])

실전 처방

* 인라인 스크립트와 인라인 이벤트 핸들러 의존을 줄이고, nonce 또는 hash 기반의 엄격한 CSP로 이동하기 ([MDN 웹 문서][8])
* SvelteKit을 쓴다면 헤더로 CSP를 거는 쪽이 운영에 유리합니다

## 5) target="_blank"는 탭 납치 입구다

`target="_blank"`로 새 탭을 열면, 새로 열린 페이지가 `window.opener`를 통해 원래 탭을 조작할 수 있습니다. MDN은 `rel="noopener"`로 이를 막으라고 설명합니다. ([MDN 웹 문서][9])

실전 처방

* 외부 링크에 `target="_blank"`를 쓰면 `rel="noopener noreferrer"`를 기본값으로

## 6) 외부 스크립트, 외부 CSS는 공급망 리스크다

`<script src="...">`와 `<link rel="stylesheet" href="...">`는 편하지만, CDN이나 서드파티가 변조되면 당신 사이트도 같이 감염됩니다. 이때 SRI가 실전 방어입니다. MDN은 SRI가 CDN 같은 외부 리소스가 예상치 않게 조작되지 않았는지 검증한다고 정리합니다. ([MDN 웹 문서][10])

실전 처방

* 외부 리소스는 가능하면 셀프 호스팅
* 꼭 써야 하면 SRI 해시와 `crossorigin`을 적용하기 ([MDN 웹 문서][10])
* 버전 고정, 변경 감지까지 같이 운영하기

## 7) 클릭재킹, 보이지 않는 iframe 위에 올려친다

결제, 설정 변경 같은 버튼이 있는 페이지가 다른 사이트의 iframe에 감싸지면 클릭재킹이 됩니다. OWASP는 X-Frame-Options 같은 헤더로 보호하라고 정리하고, MDN은 `frame-ancestors`가 더 현대적인 대안이라고 설명합니다. ([cheatsheetseries.owasp.org][11])

실전 처방

* 민감 페이지는 `frame-ancestors`로 임베딩을 막기
* 구형 대응이 필요하면 X-Frame-Options도 같이 고려 ([MDN 웹 문서][12])

## 8) 혼합 콘텐츠, HTTPS 위에 HTTP를 얹는 순간 깨진다

HTTPS 페이지에서 HTTP 리소스를 끌어오면 중간자 공격에 노출될 수 있고, 브라우저가 차단하거나 예기치 않은 동작을 합니다. MDN은 혼합 콘텐츠가 페이지를 부분적으로만 안전하게 만든다고 설명합니다. ([MDN 웹 문서][13])

실전 처방

* 모든 서브리소스를 HTTPS로 통일
* 오래된 HTTP 링크가 남는지 빌드 단계에서 검사하기

## 9) 폼은 CSRF의 본체, HTML이 방아쇠다

CSRF는 “사용자가 로그인된 상태에서, 공격자가 원치 않는 요청을 보내게 만드는 것”입니다. ([MDN 웹 문서][14])
HTML 폼은 그 트리거로 자주 쓰입니다. OWASP는 CSRF 토큰을 hidden 필드로 보내는 방식 등 방어 전략을 정리해 두었습니다. ([cheatsheetseries.owasp.org][15])

실전 처방

* 상태 변경 요청은 CSRF 토큰과 Origin 검증을 기본으로
* 쿠키 SameSite를 적절히 설정해 교차 사이트 전송을 줄이기 ([MDN 웹 문서][16])
* 토큰을 URL에 넣지 않기. 로그나 공유로 새기 쉽습니다 ([cheatsheetseries.owasp.org][15])

## 빠른 자가 점검 12개

* 사용자 입력이 HTML로 렌더되는 지점이 있는가 ([owasp.org][1])
* 사용자 입력이 속성 값에 들어가는가. href, src, data- 등 ([cheatsheetseries.owasp.org][5])
* innerHTML 같은 DOM 싱크를 쓰는가 ([portswigger.net][6])
* CSP가 약하거나 인라인 실행에 관대한가 ([MDN 웹 문서][8])
* 외부 리소스에 SRI를 붙였는가 ([MDN 웹 문서][10])
* target="_blank" 링크에 noopener를 붙였는가 ([MDN 웹 문서][9])
* 민감 페이지가 iframe에 포함될 수 있는가 ([MDN 웹 문서][12])
* HTTPS 페이지에서 HTTP 리소스를 불러오는가 ([MDN 웹 문서][13])
* 폼 기반 상태 변경 요청에 CSRF 방어가 있는가 ([cheatsheetseries.owasp.org][15])

원하면, 네가 쓰는 실제 패턴을 기준으로 더 날카롭게 줄일 수 있어요. 예를 들어 “사용자 콘텐츠를 HTML로 렌더하는 기능이 있나” 같은 질문 하나로, 우선순위가 확 갈립니다.

--------

바닐라 CSS를 쓴다고 해서 보안이 갑자기 안전해지진 않아요. 오히려 “스타일은 그냥 꾸미기”라고 생각하는 순간, 공격자는 거기로 들어옵니다. 핵심은 이것 하나예요.

CSS는 화면을 바꾸는 언어지만, 잘못 쓰이면 정보가 새고 사용자 행동이 조종된다.

아래는 사소한 건 빼고, 실제로 사고로 이어질 수 있는 것들만 모았습니다.

## 1) CSS 인젝션은 화면 장난이 아니라 데이터 유출로 이어진다

사용자 입력이 style 태그 안, style 속성, 또는 CSS 파일 경로에 섞이면 “임의 CSS 주입”이 됩니다. OWASP도 CSS 인젝션의 영향이 XSS나 데이터 유출까지 갈 수 있다고 정리해요. ([owasp.org][1])

특히 위험한 이유는 “자바스크립트가 막혀도” 데이터가 새는 경우가 있기 때문입니다.

* CSS 선택자와 외부 요청을 조합하면, 폼 필드 같은 속성 값이 조건에 따라 외부로 새어 나갈 수 있습니다. 이런 계열이 Blind CSS Exfiltration로 정리되어 있어요. ([portswigger.net][2])
* 이런 공격이 성립하려면 보통 비밀값이 DOM의 속성에 있어야 합니다. 예를 들어 hidden input의 value, OAuth 토큰이 들어간 링크, 내부 식별자가 들어간 data 속성 같은 것들이요. PortSwigger도 CSS 인젝션으로 anti-CSRF 토큰 같은 민감값이 누출될 수 있음을 명시합니다. ([portswigger.net][3])

방어 감각

* 사용자 입력을 style 태그 안에 절대 넣지 않기
* 사용자 입력을 style 속성 문자열로 합치지 않기
* 테마 기능이 필요하면 “사용자가 CSS를 쓰게” 하지 말고, CSS 변수 값만 허용하는 방식으로 제한하기
* 폼이나 DOM 속성에 토큰을 넣는 설계를 피하기. 넣어야 한다면 “CSS 주입이 가능한가”를 우선 점검하기 ([owasp.org][1])

## 2) 외부 CSS와 @import는 공급망이자 추적기다

CSS는 url()과 @import로 외부 자원을 가져올 수 있어요. 그 자체가 공격 표면입니다.

* 사용자 입력이 “스타일시트 URL”이 되거나, @import에 섞이면 CSS 인젝션으로 이어집니다. PortSwigger는 “사용자 제공 URL에서 스타일시트를 가져오는 형태”를 전형적인 원인으로 꼽아요. ([portswigger.net][3])
* 더 현실적인 문제는 외부 CDN CSS를 믿는 순간부터 시작합니다. 외부 CSS는 추적, 화면 피싱, 그리고 상황에 따라 구형 브라우저에선 XSS 급으로 악용될 수 있다는 경고가 꾸준히 있어요. ([Information Security Stack Exchange][4])

방어 감각

* 외부 CSS는 가능하면 셀프 호스팅
* 정말 써야 하면 고정 버전, 무결성 검증, 변경 감시를 갖추기
* 사용자 입력으로 CSS 경로를 만들지 않기
* 앱에서 “사용자 지정 CSS” 같은 기능은 웬만하면 금지. 해야 한다면 별도 격리된 영역에서만

## 3) CSS는 사용자 몰래 신호를 흘리는 사이드 채널이 된다

여기서부터가 재미있고 무섭습니다. CSS는 “읽기”가 아니라 “관찰”로 새게 만들 수 있어요. 이걸 XS-Leaks 같은 교차 사이트 누출 계열로 다룹니다. ([cheatsheetseries.owasp.org][5])

무슨 의미냐면

* 다른 사이트 응답의 내용은 못 읽어도, “로드가 됐는지”, “크기가 어떤지”, “무슨 상태인지” 같은 메타 정보가 새는 경우가 있어요
* 연구 쪽에서는 XS-Leaks가 꽤 넓게 존재한다고 보고합니다 ([swag.cispa.saarland][6])

CSS와 직접 관련된 대표 예시는 방문 기록, 링크 상태 같은 영역인데, 브라우저들이 많은 걸 막아놨지만 완전히 끝난 이야기는 아닙니다. xsleaks.dev도 :visited 관련 제한이 생겼다고 정리해요. ([XS-Leaks Wiki][7])

방어 감각

* 로그인 여부, 결제 여부 같은 민감 상태에 따라 페이지 구조나 리소스 로딩이 크게 달라지지 않게 설계
* 교차 출처에서 페이지가 포함되거나 관찰되는 걸 차단하는 헤더를 적극 사용
* 민감 엔드포인트 응답은 캐시와 타이밍 관찰을 최소화

## 4) CSP에서 style-src를 느슨하게 두면, “CSS 주입”의 비용이 확 떨어진다

CSP는 Content Security Policy입니다. 보통 스크립트만 신경 쓰는데, 스타일도 마찬가지예요.

* MDN은 인라인 스타일을 막는 게 CSP의 큰 이점이고, 필요하면 nonce나 hash로 제한적으로 허용하라고 안내합니다. ([MDN 웹 문서][8])

방어 감각

* style-src는 self 중심으로 두고, 인라인 스타일은 가능한 한 없애기
* 어쩔 수 없으면 nonce 또는 hash로 좁혀서 허용 ([MDN 웹 문서][8])
* 사용자 입력이 들어갈 가능성이 있는 화면은 특히 더 엄격하게

## 5) CSS로 가능한 “UI 조작”은 피싱과 동급으로 봐야 한다

CSS는 사용자를 속이기 딱 좋아요.

* 버튼을 안 보이게 만들기
* 진짜 입력창 위에 가짜 입력창 올리기
* 경고 문구를 화면 밖으로 밀어내기
* 승인 버튼 위치 바꿔서 오클릭 유도하기

이건 단독으로 터지기보다, CSS 인젝션이나 외부 CSS 변조와 붙어서 사고가 납니다. OWASP의 CSS 보안 가이드도 “사용자 제공 HTML이나 스타일이 의도와 다르게 악용될 수 있다”는 관점으로 경고합니다. ([cheatsheetseries.owasp.org][9])

방어 감각

* 사용자 콘텐츠가 섞이는 영역과 핵심 UI 영역을 물리적으로 분리
* 테마나 커스텀 스타일 기능은 “허용된 토큰만” 바꾸게 만들기
* 관리자 화면, 결제 화면은 외부 스타일 의존을 최소화

## 빠르게 점검하는 10가지 질문

* 사용자 입력이 style 태그, style 속성, CSS 파일 경로에 들어갈 여지가 있나 ([owasp.org][1])
* 사용자 입력이 들어간 화면에 hidden input, data 속성, 토큰 링크가 있나 ([portswigger.net][3])
* 외부 CSS를 @import로 당겨오나 ([portswigger.net][3])
* 외부 CDN CSS를 그냥 신뢰하고 있나 ([Information Security Stack Exchange][4])
* CSP에서 style-src에 unsafe-inline이 들어가 있나 ([MDN 웹 문서][8])
* 로그인 상태에 따라 레이아웃과 리소스 로딩이 크게 달라지나 ([cheatsheetseries.owasp.org][5])
* 민감 화면이 교차 출처로 포함될 수 있나
* “사용자 지정 CSS” 기능이 있나 ([cheatsheetseries.owasp.org][9])
* CSS에서 url()로 사용자 입력을 넣어 외부 요청이 나갈 수 있나 ([portswigger.net][3])
* 결제나 계정 화면이 외부 스타일 자원에 의존하나 ([cheatsheetseries.owasp.org][9])

---
사소한 걱정 말고, Svelte 5 + SvelteKit 2에서 진짜로 터지면 아픈 것만 추려보면 대략 7종 세트예요. 🎯

## 1) XSS는 “자동 이스케이프”를 믿는 순간부터 시작한다

Svelte 템플릿은 기본적으로 문자열을 이스케이프해요. 그래서 대부분의 출력은 안전한 편입니다. 문제는 “예외 버튼”을 누르는 순간입니다. `{@html}`은 그대로 HTML을 꽂아 넣는 기능이라, 입력이 조금이라도 사용자 영향권이면 바로 XSS 입구가 열립니다. ([Svelte][1])
OWASP도 XSS는 한 방으로 “사용자가 할 수 있는 걸 공격자가 다 하게 되는” 급이라고 못 박아요. ([cheatsheetseries.owasp.org][2])

특히 SvelteKit에는 최근(2025-04-14) “이 방식이면 XSS가 난다”가 명확히 문서화된 보안 권고가 있어요.

* 서버 `load`에서 `event.url.searchParams`의 “키 전체를 순회”하면, 검색 파라미터 이름이 서버 렌더 HTML에 비정상적으로 섞이며 XSS가 될 수 있었고
* 2.20.6에서 패치됐습니다 ([GitHub][3])

실전 처방

* SvelteKit 버전은 최소 2.20.6 이상으로 올리기 ([GitHub][3])
* 서버 `load`에서 searchParams 키 전체 순회 피하기
  정말 필요하면 “허용된 키 목록”만 읽기
* 사용자 콘텐츠를 HTML로 렌더해야 한다면

  1. 서버에서 정화한 뒤 저장하거나
  2. 렌더 직전에 정화하고
  3. CSP까지 같이 걸기

그리고 CSP는 방탄복 중 하나예요. SvelteKit 설정에서 CSP 헤더를 붙일 수 있습니다. ([Svelte][4])

## 2) CSRF는 “설정 한 줄”로 방어를 걷어차기 쉽다

SvelteKit은 기본적으로 폼 제출에서 Origin 검사로 CSRF를 막습니다. 그리고 “교차 출처 폼 제출을 허용하는 예외 목록”도 따로 있어요. ([Svelte][4])
여기서 위험한 선택은 딱 두 가지입니다.

* Origin 검사 끄기
* 신뢰 출처를 과하게 넓히기

과거 SvelteKit 1에서 Content-Type 변형으로 CSRF 방어가 뚫린 적도 있었고, 패치와 함께 “메서드 범위 확대, Content-Type 처리 강화” 같은 하드닝이 들어갔어요. “프레임워크가 막아주겠지”보다 “최신 패치 유지”가 더 현실적인 보험입니다. ([GitHub][5])

추가로, 인증 쿠키의 SameSite를 None으로 두면 CSRF 난이도가 내려갈 수 있다는 얘기도 권고문에 직접 나옵니다. ([GitHub][6])

## 3) 세션과 쿠키는 “편의성”이 아니라 “경계선”이다

SvelteKit으로 로그인 붙일 때 가장 흔한 대형 사고는 토큰을 브라우저 저장소에 넣는 거예요. XSS가 한 번이라도 나면 싹 털립니다.
세션 토큰은 보통 HttpOnly 쿠키로 두고, 수명과 회전 정책을 명확히 잡는 게 정석이에요. 세션 관리의 기본 원칙은 OWASP가 아주 길게 정리해 두었습니다. ([cheatsheetseries.owasp.org][7])

실전 처방

* 세션 토큰은 HttpOnly 쿠키 중심
* 로그인 직후 세션 ID 재발급, 권한 상승 시 재발급
* 로그아웃 시 무효화 확실히
* 민감 API는 재인증 또는 추가 확인

## 4) “서버에서만 안다”는 착각, load와 직렬화가 배신한다

SvelteKit에서 데이터가 새는 루트는 의외로 단순해요.

* `load`가 반환한 값은 서버 렌더 HTML에 포함될 수 있다
* 그래서 `load` 리턴은 기본적으로 “공개 데이터”라고 생각하는 게 안전합니다 ([Svelte][8])

또 환경 변수도 “공개 접두사”가 기본으로 정해져 있어요. 공개 접두사로 시작하는 값은 클라이언트로 노출될 수 있다는 뜻입니다. ([Svelte][4])

실전 처방

* 공개 접두사 붙은 변수에는 절대 비밀 넣지 않기 ([Svelte][4])
* 서버 전용 값은 서버 전용 모듈과 서버 라우트에서만 사용
* `load` 리턴에는 토큰, 내부 식별자, 결제 관련 원본 데이터 넣지 않기
* 헤더 직렬화 같은 옵션을 쓸 때도 “노출돼도 되는 것만” 화이트리스트로

## 5) SSRF는 “서버 fetch 대행” 기능 만들 때 가장 잘 생긴다

예를 들어 이미지 프록시, 링크 미리보기, 외부 문서 가져오기 같은 걸 만들면, 공격자는 내부망 주소나 메타데이터 엔드포인트를 찌르려고 해요.
OWASP의 핵심 권고는 한 줄로 요약됩니다. 사용자 제공 URL은 블랙리스트가 아니라 허용 목록으로 다뤄라. ([owasp.org][9])

실전 처방

* 프로토콜은 https만 허용
* 호스트는 허용 목록 기반
* 리다이렉트는 제한
* IP 직접 입력 차단, 로컬 대역 차단
* URL 파싱과 검증을 같은 방식으로 수행

## 6) PWA와 서비스 워커는 “보안에선 캐시가 독이다”

서비스 워커는 성능 마법사인데, 로그인 이후 페이지나 개인화 API 응답을 캐시에 저장하면 그 순간부터 데이터가 “디스크에 남는 유출물”이 됩니다.
민감 응답은 Cache-Control no-store로 못 박는 게 기본 중 기본이에요. ([MDN 웹 문서][10])

실전 처방

* 인증 이후 화면, 계정 API는 no-store ([MDN 웹 문서][10])
* 서비스 워커에서 credentials 포함 요청은 캐시 우회
* 오프라인 페이지에는 개인정보 섞지 않기

## 7) 의존성 공급망은 2025년에 더 시끄러워졌다

요즘 프론트 보안의 진짜 전쟁터는 “내 코드”가 아니라 “내가 설치한 코드”인 경우가 많아요.
2025년에 대형 npm 공급망 공격 캠페인들이 계속 보고됐고, 잠깐 계정이 탈취돼도 악성 버전이 배포되는 사례가 반복됐습니다. ([Tom's Hardware][11])
패키지 설치 스크립트도 공격 표면이 될 수 있다는 얘기가 꾸준히 나와요. ([nodejs-security.com][12])

실전 처방

* 락파일을 커밋하고, 업데이트는 PR 단위로 보기
* GitHub 보안 권고, Dependabot 같은 자동 알림 켜기
* 새 의존성 추가 시 유지보수 상태, 다운로드 수, 최근 릴리즈 확인
* 설치 스크립트가 필요한 패키지는 “왜 필요한지”를 설명할 수 있을 때만

## 바로 적용용 체크리스트 12개

* SvelteKit을 최소 2.20.6 이상 유지 ([GitHub][3])
* 서버 load에서 searchParams 키 전체 순회 금지 ([GitHub][3])
* 사용자 입력을 `{@html}`로 렌더 금지 ([Svelte][1])
* CSP를 기본값으로 두고, 필요한 도메인만 점진적으로 추가 ([Svelte][4])
* CSRF 관련 설정은 기본값을 존중하고, 예외는 최소화 ([Svelte][4])
* 인증 쿠키 SameSite를 None으로 두는 선택은 정말 마지막에 ([GitHub][6])
* 세션 토큰은 HttpOnly 쿠키 중심으로 설계 ([cheatsheetseries.owasp.org][7])
* `load` 리턴은 공개 데이터라고 가정 ([Svelte][8])
* 공개 접두사 환경 변수에는 비밀 금지 ([Svelte][4])
* 서버에서 외부 URL fetch는 허용 목록 기반 ([owasp.org][9])
* 민감 응답은 no-store ([MDN 웹 문서][10])
* 의존성 업데이트는 자동이 아니라 “검토 가능한 이벤트”로 ([Cyber Security Agency of Singapore][13])

---

Bun은 빠릅니다. 동시에 아주 많은 권한을 쥔 도구예요. 런타임, 패키지 매니저, 번들러가 한 몸이라서 한 번 삐끗하면 개발 환경이나 CI 토큰이 통째로 빨려 들어갈 수 있습니다. 그래서 여기서는 진짜로 크게 터질 수 있는 것만 추렸습니다.

1. 설치 과정에서 실행되는 스크립트
   공격자가 가장 좋아하는 건 postinstall 같은 설치 훅입니다. 패키지 설치만 했는데도 임의 코드가 실행될 수 있으니까요. Bun은 이 위험을 줄이려고, 신뢰되지 않은 의존성의 설치 스크립트를 막고 allowlist 방식으로만 풀어주는 흐름을 제공합니다. trustedDependencies에 넣거나 bun pm trust로 허용하는 방식이죠. ([Bun][1])

* 위험 시나리오

  * 악성 패키지가 설치 훅에서 CI 환경변수, 레지스트리 토큰, SSH 키를 훔쳐감
  * 개발 PC에서 파일을 수정하거나 백도어를 심음
* 방어 습관

  * 기본값은 막힌 상태로 두고, 정말 필요한 패키지만 trustedDependencies에 추가 ([Bun][1])
  * 설치 후 bun pm untrusted로 어떤 패키지의 어떤 스크립트가 막혔는지 확인 ([Bun][2])
  * 전체를 한 번에 풀어주는 bun pm trust --all은 거의 비상 탈출 버튼 취급

2. bunx로 외부 CLI를 즉석 실행하는 습관
   bunx는 npx처럼 npm에서 패키지를 자동 설치해서 실행합니다. 그리고 설치된 패키지는 전역 캐시에 남습니다. 한 번 잘못 실행하면 그 잘못이 다음에도 재사용되기 쉬워요. ([Bun][3])

* 위험 시나리오

  * 패키지 이름 오타로 악성 패키지를 실행하는 타이포스쿼팅 ([docs.npmjs.com][4])
  * CI에서 bunx로 도구를 매번 즉석 설치해서 실행하다가, 공급망 변조 한 번에 뚫림
* 방어 습관

  * 가능하면 도구는 devDependencies로 고정하고 bun run으로 실행
  * 어쩔 수 없이 bunx를 쓰면 버전을 명시해서 실행. bunx 패키지@버전 형태 ([Bun][3])
  * CI에서는 bunx --no-install로 “이미 설치된 것만” 허용하는 정책도 고려 ([Bun][3])

3. 레지스트리 설정과 토큰 관리
   Bun은 기본 레지스트리가 registry.npmjs.org이고, bunfig.toml이나 .npmrc로 스코프별 레지스트리와 토큰을 설정할 수 있습니다. 편한 만큼 사고도 자주 납니다. ([Bun][5])

* 위험 시나리오

  * 사내 패키지 이름이 퍼블릭 레지스트리와 충돌하면 dependency confusion 공격이 가능 ([blog.gitguardian.com][6])
  * bunfig.toml, .npmrc에 토큰을 적어두고 레포에 실수로 커밋
* 방어 습관

  * 조직 스코프 패키지는 항상 전용 레지스트리로 고정 ([Bun][5])
  * 토큰은 파일에 박제하지 말고, 가능하면 CI 시크릿로 주입
  * 내부 패키지 이름은 퍼블릭 레지스트리에도 선점해 confusion 여지를 줄이기 ([blog.gitguardian.com][6])

4. 락파일을 느슨하게 다루면 배포가 조용히 변질됨
   Bun은 bun.lock을 쓰고, 재현 가능한 설치를 위해 frozen lockfile 옵션을 제공합니다. 이걸 안 쓰면 의존성이 “그날의 레지스트리 기분”을 타요. ([Bun][7])

* 위험 시나리오

  * CI가 bun install을 도는 사이에, 같은 package.json인데도 설치 결과가 달라짐
  * 악성 업데이트가 슬쩍 섞여 들어와도 눈치채기 어려움
* 방어 습관

  * CI는 bun install --frozen-lockfile을 기본으로 ([Bun][7])
  * 운영 배포는 bun install --production으로 개발용 의존성 자체를 줄이기 ([Bun][7])

5. 전역 캐시와 공유 환경
   Bun은 받은 패키지를 전역 캐시에 보관합니다. 기본 경로는 ~/.bun/install/cache이고 환경변수로 바꿀 수 있어요. ([Bun][8])

* 위험 시나리오

  * 여러 프로젝트, 여러 작업이 같은 캐시를 공유하면 “어디서 들어온 물건인지” 추적이 어려워짐
  * 팀 공용 계정, 공용 빌드 머신 이미지에서 캐시가 꼬이면 문제 재현도 보안 점검도 힘들어짐
* 방어 습관

  * CI에서는 BUN_INSTALL_CACHE_DIR로 캐시를 파이프라인 단위로 분리 ([Bun][8])
  * 이상 징후가 있으면 bun pm cache rm로 초기화하고 다시 고정 설치 ([Bun][7])

6. bun patch의 파급 범위
   bun patch는 패키지를 고쳐 쓰는 강력한 도구인데, 패치된 결과가 전역 캐시에 들어가 다른 프로젝트와 공유될 수 있습니다. ([Bun][9])

* 위험 시나리오

  * 한 프로젝트를 살리려고 넣은 패치가 다른 프로젝트에도 영향을 주며, 원인 모를 동작 변화가 발생
* 방어 습관

  * patch는 “코드 변경”으로 취급하고 리뷰와 기록을 남기기
  * 공용 환경에서 무심코 patch를 쓰지 않기 ([Bun][9])

7. 번들러가 서버 비밀을 프론트로 같이 싸버리는 사고
   Bun 번들러는 프론트 자산과 백엔드 서버를 한 번에 묶어 단일 배포물로 만들 수 있습니다. 편하지만, 경계가 흐려지면 비밀도 같이 딸려 나갑니다. ([Bun][10])

* 위험 시나리오

  * 서버 전용 키, 내부 엔드포인트, 관리자 로직이 클라이언트 번들에 섞임
* 방어 습관

  * 엔트리포인트를 서버용과 클라이언트용으로 분리
  * 번들 결과물에 민감 문자열이 들어갔는지 정기적으로 확인

8. 스캐너와 감사 기능을 꺼놓으면, 눈을 감고 달리는 셈
   Bun에는 취약점 점검용 bun audit이 있고, 설치 전에 스캐너를 붙여서 위험도가 치명적인 경우 설치를 취소하게 만들 수도 있습니다. ([Bun][11])

* 추천 운용

  * PR이나 배포 파이프라인에 bun audit를 기본으로 ([Bun][11])
  * bunfig.toml에서 install.security.scanner를 설정해서 설치 전에 차단 ([Bun][12])

바로 적용하는 현실적인 규칙 세트

* 로컬 개발

  * 새 패키지 추가는 이벤트다. 왜 필요한지 먼저 적고, 설치 뒤 bun pm untrusted 확인 ([Bun][2])
  * bunx는 되도록 버전 명시, 낯선 패키지는 즉석 실행 금지 ([Bun][3])
* CI

  * bun install --frozen-lockfile, 가능하면 --production ([Bun][7])
  * BUN_INSTALL_CACHE_DIR로 캐시 분리 ([Bun][8])
  * bun audit와 설치 전 스캐너 활성화 ([Bun][11])
* 운영 배포

  * 설치 훅은 최소화, trustedDependencies는 최소 allowlist로 유지 ([Bun][1])
---
UnoCSS를 쓰면 보안 위협이 갑자기 새로 생긴다기보다, 기존 위험이 더 쉽게 현실이 됩니다. 이유는 단순해요. 클래스 문자열 한 줄이 곧 CSS 규칙 생성으로 이어지기 때문입니다. UnoCSS는 코드베이스에서 유틸 사용을 찾아 CSS를 생성하는 방식입니다. ([unocss.dev][1])

아래는 사소한 건 빼고, 실제로 크게 터질 수 있는 것들만 골랐습니다.

1. 클래스 주입이 곧 화면 장악으로 이어지는 문제
   전제가 하나 있어요. 사용자 입력이 class 속성이나 attributify 속성에 들어갈 수 있어야 합니다. 그 순간부터는 XSS 한 발 전 단계만 뚫려도 UI가 통째로 바뀝니다.

* 왜 위험한가

  * 공격자가 화면을 덮는 레이어, 가짜 로그인 폼, 클릭 유도 요소를 CSS로 만들 수 있습니다
  * 보안 경계는 서버인데, 사용자는 브라우저에서 속습니다. 결제나 계정 연결 같은 흐름에서 특히 치명적이에요
* UnoCSS가 위험을 키우는 지점

  * arbitary variants 같은 기능은 선택자를 넓혀서 다른 요소까지 스타일을 뻗게 만들 수 있습니다. 예를 들어 [&>*]: 같은 형태가 기본 추출 범위에 들어갑니다 ([unocss.dev][2])
  * attributify를 켜면 class뿐 아니라 속성 형태로도 유틸이 적용됩니다. 즉 공격 표면이 넓어집니다 ([unocss.dev][3])
* 방어 방법

  * 사용자 입력이 class로 합쳐지는 코드를 금지하세요. 문자열 합성 대신, 미리 정의한 맵에서만 고르게 만드세요
  * 마크다운이나 HTML 렌더링에서 class와 style 속성은 기본 차단이 안전합니다. 허용해야 한다면 허용 목록 기반으로 아주 좁게
  * arbitrary variants를 팀 규칙으로 제한하세요. 화면 전체에 영향 줄 수 있는 형태는 리뷰에서 즉시 걸러야 합니다 ([unocss.dev][2])

2. 런타임 생성 모드 사용 시 브라우저가 멈추는 유형의 공격
   UnoCSS는 브라우저에서 DOM 변화를 감지해서 스타일을 즉석 생성하는 런타임 모드가 있습니다. ([unocss.com.cn][4])
   이건 생산성 도구로는 재밌지만, 운영 환경에선 공격 표면이 됩니다.

* 왜 위험한가

  * DOM이 크거나 변화가 많으면 페이지가 멈출 수 있습니다. 실제로 런타임이 모든 엘리먼트를 훑으며 버벅인다는 보고가 있어요 ([GitHub][5])
  * 공격자가 댓글, 게시글, 리스트 같은 반복 렌더링을 유도하면 저사양 기기에서 서비스 거부로 이어질 수 있습니다
* 방어 방법

  * 운영에서는 런타임 모드 자체를 쓰지 않는 쪽이 가장 확실합니다
  * 어쩔 수 없이 쓴다면, 유틸이 적용되는 영역을 최대한 좁히고, 사용자 생성 컨텐츠가 들어가는 영역은 스타일 생성 대상에서 빼는 전략을 고려하세요

3. 정규식 기반 서비스 거부, 개발 서버와 CI가 멈추는 문제
   UnoCSS 생태계에는 복잡한 변형 문법을 추출하기 위한 extractor가 있고, 그중 일부 버전에서 ReDoS 취약점이 보고된 적이 있습니다. 특정 버전 구간에서 정규식 서비스 거부가 가능했고 이후 수정 버전이 나왔습니다. ([intel.aikido.dev][6])

* 왜 위험한가

  * 빌드가 멈추면 배포가 멈춥니다. 1인 개발자에겐 곧 매출 중단입니다
  * 컨텐츠 기반 빌드, 즉 사용자 입력을 빌드 파이프라인이나 서버 렌더 단계에서 스캔하는 구조라면 더 위험해집니다
* 방어 방법

  * UnoCSS와 extractor 관련 패키지는 보안 업데이트를 빠르게 따라가세요. 특히 arbitrary variants extractor 계열은 주기적으로 확인 ([intel.aikido.dev][6])
  * 커스텀 rule, shortcut을 정규식으로 만들 때는 앵커를 걸고 입력 길이를 제한하세요. greedy 패턴은 피하는 게 안전합니다 ([tutorial.unocss.dev][7])

4. 아이콘과 웹폰트 프리셋이 만드는 외부 네트워크 의존성
   겉으로는 UI 기능이지만, 실제로는 보안과 프라이버시 이슈로 연결됩니다.

* 웹폰트

  * web-fonts 프리셋은 기본적으로 공급자 CDN에서 폰트를 가져옵니다. 원하면 로컬 서빙으로 바꾸는 옵션도 문서에 있습니다 ([unocss.dev][8])
  * 위험은 두 가지예요. 사용자의 접속 정보가 외부로 나가고, 외부 장애가 곧 내 서비스 장애가 됩니다
* 아이콘

  * icons 프리셋은 Iconify 데이터를 기반으로 아이콘을 생성합니다 ([iconify.design][9])
  * 렌더링이 background-image나 mask 형태가 될 수 있습니다. 즉 CSS 안에 이미지 형태가 들어갑니다 ([unocss.dev][10])
* 방어 방법

  * 폰트는 가능하면 로컬 서빙으로 전환하고, 아이콘도 빌드 시점에 고정된 자산으로 만들거나 네트워크 의존을 최소화하세요 ([unocss.dev][8])
  * CSP에서 font-src, img-src를 좁혀두면 사고 범위를 줄일 수 있습니다. 특히 사용자 컨텐츠가 렌더되는 서비스라면 더 중요해요

5. 전역 스타일 주입으로 인한 예상 밖의 영향 범위
   Vite 통합에서 기본 모드는 전역 스타일 시트로 주입되는 형태입니다. ([unocss.dev][11])
   이건 기능적으로 편하지만, 컴포넌트 경계가 약해져서 한 줄의 클래스가 예상보다 넓게 영향을 줄 때가 있어요.

* 왜 위험한가

  * 보안 취약점이라기보단, 보안 사고를 만들기 쉬운 환경이 됩니다. UI가 흔들리면 사용자가 속기 쉬워져요
* 방어 방법

  * 사용자 입력이 스타일에 영향을 주는 영역은 가능한 한 격리하세요. 컨텐츠 렌더 영역을 별도 컴포넌트로 분리하고 허용 유틸을 제한하는 식으로요
  * 변형과 shortcut을 늘릴수록 “무엇이 어디에 적용되는지” 추적 비용이 올라갑니다. 팀 규칙으로 상한선을 두는 게 장기적으로 안전합니다

지금 당장 적용할 우선순위

1. class에 사용자 입력을 합치는 패턴 금지, 맵 기반 선택만 허용
2. 운영에서 런타임 모드 사용 금지 ([unocss.com.cn][4])
3. extractor 관련 패키지 보안 업데이트 점검, ReDoS 이력 있는 패키지 버전 관리 강화 ([intel.aikido.dev][6])
4. web-fonts는 로컬 서빙으로 전환, icons도 외부 의존 최소화 ([unocss.dev][8])
5. arbitrary variants와 attributify는 “필요한 곳만” 켜고, 컨텐츠 렌더 영역에는 원칙적으로 금지 ([unocss.dev][2])
---

TypeScript로 웹사이트를 만든다고 해서 공격 표면이 “타입”만큼 줄어들진 않아요. 컴파일이 끝나면 결국 런타임은 JavaScript고, 공격자는 타입 체커가 아니라 네트워크 경계와 설정 구멍을 두드리거든요. 그래서 여기서는 실제로 크게 터지는 것들만 골라서, 어디서 사고가 나고 어떻게 막는지까지 붙여볼게요.

## 1) 권한 통제 실패

가장 흔하고, 한 번 나면 가장 비쌉니다. OWASP Top 10에서도 계속 1번 자리를 잡고 있어요. ([owasp.org][1])

* 전형적인 폭발 지점

  * “로그인 했으니 OK” 같은 상태 기반 체크만 하고, 리소스 소유권 체크를 안 함
  * 클라이언트에서 role을 내려주고 그걸 믿음
  * 멀티테넌트에서 tenant 경계를 쿼리로만 나눴다고 착각함
* 방어 습관

  * 권한은 서버에서만 판정, 매 요청마다 “이 사용자가 이 리소스에 접근해도 되는가”를 확인
  * 권한 체크를 라우트마다 흩뿌리지 말고, 정책 함수로 중앙화
  * “기본 거부”가 기본값. 허용 규칙만 추가

## 2) 설정 실수

요즘은 코드보다 설정이 더 많은 세상이라, OWASP 2025에서는 설정 문제가 2위로 올라왔어요. ([owasp.org][2])

* 전형적인 폭발 지점

  * CORS를 와일드카드로 열어두고 쿠키까지 함께 보냄
  * 스토리지 버킷, 로그 대시보드, 관리자 패널이 인터넷에 노출
  * 보안 헤더 미설정, 잘못된 캐시 설정으로 민감 응답이 공유 캐시에 남음
* 방어 습관

  * 배포 설정을 코드처럼 다루기. 변경 이력, 리뷰, 릴리스 체크리스트
  * 보안 헤더 기본값 묶기. CSP, HSTS, X-Frame-Options 계열
  * “프리뷰 환경”도 똑같이 잠그기. 사고는 늘 덜 신경 쓴 곳에서 납니다

## 3) 소프트웨어 공급망 공격

2025 Top 10에서 아예 “소프트웨어 공급망 실패”가 별도 카테고리로 크게 올라왔죠. 의존성, 빌드, 배포 경로가 공격 통로가 됩니다. ([owasp.org][2])

* 전형적인 폭발 지점

  * npm 패키지 탈취, 유지보수자 계정 탈취
  * 유사 패키지 이름으로 유도하는 typosquatting
  * 사내 비공개 패키지 이름이 퍼블릭 레지스트리와 충돌하는 dependency confusion ([blog.doyensec.com][3])
* 방어 습관

  * 락파일 고정, 자동 업데이트는 PR로만, 리뷰 없이 병합 금지
  * “새 패키지 추가”는 보안 이벤트 취급. 왜 필요한지, 대체재는 없는지
  * CI 토큰 권한 최소화, 레지스트리 토큰을 사람 계정이 아니라 자동화 전용으로 분리
  * 가능하면 provenance 같은 출처 증명 기능을 적극 활용 ([The GitHub Blog][4])

## 4) 입력 기반 공격

이름은 “인젝션” 하나로 뭉뚱그려지지만, 실제로는 SQL, NoSQL, 템플릿, 커맨드, XSS까지 한 가족이에요. OWASP에서도 큰 축으로 계속 남아 있습니다. ([owasp.org][2])

* 전형적인 폭발 지점

  * 문자열 조합 쿼리
  * 서버에서 URL을 받아 내부로 요청하는 기능, 즉 SSRF
  * 사용자 입력을 그대로 HTML로 주입하는 DOM XSS
* 방어 습관

  * 쿼리는 무조건 파라미터 바인딩
  * 서버에서 나가는 요청은 “허용된 호스트 목록” 기반으로만
  * HTML 삽입이 필요한 경우는 극도로 제한하고, 컨텐츠는 정화 라이브러리와 CSP로 이중 잠금

## 5) 인증 실패와 세션 관리

로그인이 “되는 것”과 “안전하게 유지되는 것”은 다른 이야기예요. OWASP 2025에서도 인증 실패가 별도 카테고리로 남아 있습니다. ([owasp.org][2])

* 전형적인 폭발 지점

  * 세션 쿠키에 HttpOnly, Secure, SameSite 설정 누락
  * 리프레시 토큰을 로컬 스토리지에 저장
  * 비밀번호 재설정 링크가 너무 오래 살아있음
* 방어 습관

  * 쿠키 기본값은 HttpOnly + Secure + 적절한 SameSite
  * 토큰 수명과 회전 전략을 먼저 설계하고 구현은 나중
  * 로그인 시도, 비밀번호 재설정 요청은 반드시 속도 제한

## 6) 암호화 실패와 비밀 관리

암호화는 알고리즘보다 “키와 운용”에서 터져요. OWASP에서도 키를 코드 저장소에 올리는 실수를 대표 질문으로 콕 찍습니다. ([owasp.org][5])

* 전형적인 폭발 지점

  * API 키, 암호화 키, 서비스 계정 파일이 레포에 커밋
  * 개발 환경 키를 운영에 재사용
  * TLS 종단과 내부 구간을 믿고 민감정보를 평문으로 굴림
* 방어 습관

  * 비밀은 전용 저장소로만, 회전이 가능한 형태로
  * 키를 “생성, 배포, 회전, 폐기”까지 하나의 라이프사이클로 관리
  * 로그에 민감정보가 섞이지 않게 필터링

## 7) 예외 처리 실패와 장애 유도

OWASP 2025에 새로 들어온 주제 중 하나가 “비정상 조건 처리 실패”예요. 오류가 날 때 시스템이 안전하게 닫히지 않고, 열려버리는 순간이 많거든요. ([owasp.org][2])

* 전형적인 폭발 지점

  * try catch에서 에러를 삼키고 기본값으로 진행, 즉 fail open
  * 권한 체크 중 오류가 나면 “일단 통과”
  * 입력 검증 실패가 500으로 터지며 내부 스택이 노출
* 방어 습관

  * 보안 관련 분기에서 오류가 나면 거부가 기본
  * 에러 메시지는 사용자용과 내부용을 분리
  * 관측 가능성, 즉 로깅과 알림을 같이 설계. “로그는 있는데 아무도 안 봄”은 무방비와 비슷합니다 ([owasp.org][2])

## 8) TypeScript가 특히 위험하게 만드는 착시 3가지

TypeScript는 안전벨트인데, 가끔 “운전 실력이 늘었다”는 착각을 줍니다.

* 타입은 런타임에서 사라짐

  * 클라이언트에서 온 JSON은 어떤 타입도 아닙니다. 서버 경계에서 스키마 검증을 통과한 뒤에만 타입을 부여하세요
* as, any가 권한 우회로가 됨

  * “일단 캐스팅”은 “일단 무장해제”와 닮아 있습니다. 특히 권한, 결제, 관리자 기능 주변에서는 금지에 가깝게 다루는 게 좋아요
* 공유 객체 병합이 오염 통로가 됨

  * 깊은 병합, 객체 펼침, 설정 합치기 같은 코드가 공격 입력과 만나면 예기치 않은 속성이 끼어들 수 있어요. 서버 설정, 권한 정책 객체는 불변 구조로 다루는 편이 안전합니다

## 오늘 당장 적용하는 우선순위 체크리스트

* 서버 경계에서 입력 스키마 검증을 강제, 통과 전에는 어떤 타입도 믿지 않기
* 권한 체크를 중앙화하고 기본 거부로 설계
* CORS, 쿠키, 보안 헤더를 “안전 기본값 세트”로 템플릿화
* 의존성 추가와 업데이트를 PR로 통제, 락파일 고정
* 비밀은 레포 밖에서 관리, 토큰 권한 최소화와 정기 회전
* 외부로 나가는 서버 요청은 허용 목록 기반으로, SSRF 방어
* 에러는 fail closed, 로그와 알림은 세트로
---


