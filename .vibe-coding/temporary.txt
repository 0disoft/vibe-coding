전체적으로 방향은 좋아. 딱 “구두점으로 끝나는 볼드가 한글 조사랑 붙을 때”를 겨냥했고, 파일 워크도 단순해서 운영하기 편해.

다만 지금 그대로 쓰면 3가지가 꽤 크게 아쉽다.

* 반복 실행하면 계속 덧붙이는 문제
  지금은 “이미 제로폭 공백 엔티티가 들어간 상태”도 다시 매칭돼서, 실행할 때마다 `&#8203;`가 누적될 수 있어. 이유는 네가 넣는 값이 실제 유니코드 제로폭 공백이 아니라 문자열 엔티티라서, 다음 글자가 `&`로 시작하기 때문이야.
* 코드 블록과 인라인 코드도 같이 고쳐버릴 수 있음
  문서 안에 예시 코드가 많으면, “깨지는 예시”를 “안 깨지는 예시”로 바꿔버리거나 반대로 예시를 망가뜨릴 수 있어.
* 매칭 범위가 조금 과함
  “공백 아닌 문자” 전부를 대상으로 하다 보니, 실제로 필요한 케이스보다 넓게 잡힐 수 있어. 이건 오탐을 부르는 쪽이야.

아래는 위 3개를 한 번에 잡는 개선 버전이야. 핵심은 2가지.

* 닫힘 뒤가 한글이나 CJK 문자일 때만 삽입해서 오탐을 확 줄임
* 펜스 코드블록과 인라인 코드 구간은 건너뜀
* 추가로 “멱등성” 보장. 여러 번 돌려도 결과가 더 변하지 않게 함

아래 코드는 별표 문자를 코드에 직접 쓰지 않게 구성했어.

````ts
import { readdir, readFile, writeFile } from "node:fs/promises";
import { extname, join } from "node:path";

const TARGET_DIR = process.argv[2] || "src/content";
const DRY_RUN = process.argv.includes("--dry-run");

// 제로폭 공백을 HTML 엔티티로 넣는 방식 유지
const ZWS_ENTITY = "&#8203;";

// 별표 문자 직접 사용을 피함
const STAR = String.fromCharCode(42);
const STRONG = STAR + STAR;

// 다음 글자가 한글 또는 주요 CJK 스크립트일 때만 처리
const NEXT_IS_CJK =
  "[\\p{Script=Hangul}\\p{Script=Han}\\p{Script=Hiragana}\\p{Script=Katakana}]";

// 볼드 내부 마지막 글자가 구두점으로 끝나는 패턴만
const PUNCT_AT_END = "[.:;!?)]";

// 멱등성 보장 포인트
// - 닫힘 다음이 CJK일 때만 삽입하므로, 이미 엔티티가 들어간 경우 다음 글자가 &가 되어 재매칭되지 않음
const punctuationRegex = new RegExp(
  `(${STRONG}(?:(?!${STRONG}).)+?${PUNCT_AT_END}${STRONG})(?=${NEXT_IS_CJK})`,
  "gu"
);

async function walk(dir: string): Promise<string[]> {
  const files: string[] = [];
  const entries = await readdir(dir, { withFileTypes: true });

  for (const entry of entries) {
    const path = join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...(await walk(path)));
    } else if (entry.isFile()) {
      const ext = extname(path);
      if (ext === ".md" || ext === ".mdx") files.push(path);
    }
  }
  return files;
}

function fixLineOutsideInlineCode(line: string): { line: string; replaced: number } {
  // 아주 단순한 인라인 코드 회피
  // 백틱으로 split하고 짝수 인덱스만 변환
  const parts = line.split("`");
  let replaced = 0;

  for (let i = 0; i < parts.length; i += 2) {
    const before = parts[i];
    const after = before.replace(punctuationRegex, (m) => {
      replaced += 1;
      return m + ZWS_ENTITY;
    });
    parts[i] = after;
  }

  return { line: parts.join("`"), replaced };
}

function fixMarkdownKeepingCodeFences(content: string): { content: string; replaced: number } {
  const lines = content.split("\n");
  let inFence = false;
  let fenceToken = "";
  let replaced = 0;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    const trimmed = line.trimStart();
    const fenceStarts =
      trimmed.startsWith("```") || trimmed.startsWith("~~~");

    if (!inFence && fenceStarts) {
      inFence = true;
      fenceToken = trimmed.slice(0, 3);
      continue;
    }

    if (inFence) {
      const fenceEnds = trimmed.startsWith(fenceToken);
      if (fenceEnds) {
        inFence = false;
        fenceToken = "";
      }
      continue;
    }

    const fixed = fixLineOutsideInlineCode(line);
    lines[i] = fixed.line;
    replaced += fixed.replaced;
  }

  return { content: lines.join("\n"), replaced };
}

async function fixFile(path: string) {
  const original = await readFile(path, "utf-8");
  const fixed = fixMarkdownKeepingCodeFences(original);

  if (fixed.content !== original) {
    console.log(`[FIX] ${path}  changes=${fixed.replaced}`);
    if (!DRY_RUN) {
      await writeFile(path, fixed.content, "utf-8");
    }
  }
}

async function main() {
  console.log(`Scanning directory: ${TARGET_DIR}`);
  if (DRY_RUN) console.log("DRY RUN MODE: No files will be modified.");

  try {
    const files = await walk(TARGET_DIR);
    console.log(`Found ${files.length} markdown files.`);

    for (const file of files) {
      await fixFile(file);
    }

    console.log("Done.");
  } catch (error) {
    console.error("Error:", error);
  }
}

main();
````

추가로 추천하는 작은 개선

* `--extensions` 옵션을 만들어서 `.svx` 같은 것도 필요하면 포함
* `--include` `--exclude` 패턴을 받아서 특정 폴더나 파일만 대상으로 하기
* 리포팅을 더 친절하게
  파일별 변경 개수 합산, 총 변경 개수 출력
