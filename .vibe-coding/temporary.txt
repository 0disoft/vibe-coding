전반적으로 매우 훌륭하게 작성된 코드입니다. Svelte 5의 Runes 시스템(`$state`)을 올바르게 적용했고, SSR 환경에서 클라이언트 하이드레이션(Hydration) 시 발생할 수 있는 스타일 불일치(FOUC) 문제를 해결하기 위해 `data-*` 속성을 우선순위로 둔 점이 인상적입니다.

특히 `allowedValues`를 통한 유효성 검사 로직과 DOM/Cookie 동기화 로직이 견고합니다.

몇 가지 **엣지 케이스 처리**와 **코드 중복 제거**, **유지보수성**을 위해 개선된 버전을 제안합니다.

### 개선 제안 사항

1.  **파싱 로직 중복 제거 (DRY 원칙)**
    `init` 함수 내에서 DOM 속성과 쿠키 값을 파싱하고 검증하는 로직이 거의 동일하게 반복됩니다. 이를 내부 헬퍼 함수로 추출하면 가독성이 좋아집니다.

2.  **초기화 시 불필요한 DOM 쓰기 방지**
    DOM에서 값을 읽어와 초기화했을 경우(`init`의 1번 케이스), 이미 DOM에는 올바른 값이 있으므로 `updateDom`을 호출할 필요가 없습니다. 현재 코드는 잘 처리되어 있으나, 쿠키에서 읽어온 경우(2번 케이스)에는 DOM이 비어있을 수 있으므로 동기화가 필요합니다. 이 흐름을 명확히 정리했습니다.

3.  **Svelte 5 바인딩 호환성 (선택 사항)**
    현재 `get current()`와 `set(val)` 형태는 데이터 흐름을 명시적으로 제어하기에 좋습니다. 만약 `<input bind:value={store.current} />` 처럼 양방향 바인딩을 원하신다면 `get/set` 접근자를 가진 클래스나 객체 프로퍼티 형태로 변경해야 합니다. 하지만 현재 구조가 "설정값 관리"라는 목적에는 더 안전하므로 현재 구조를 유지하며 최적화했습니다.

4.  **`number` 타입 변환 안전장치 강화**
    `Number('')`는 `0`이 됩니다. 빈 문자열이 들어왔을 때 숫자형 설정값(예: 폰트 사이즈)이 0이 되는 것을 방지하기 위해 빈 문자열 체크를 명확히 했습니다.

-----

### 개선된 코드 (Refined Version)

```typescript
// src/lib/stores/persisted-state.svelte.ts
import { browser } from '$app/environment';

// Note: 이 파일은 Svelte runes($state)을 사용하므로 .svelte.ts 확장자를 유지하세요.

// ─────────────────────────────────────────────────────────────────────────────
// 상수
// ─────────────────────────────────────────────────────────────────────────────

const DEFAULT_COOKIE_DAYS = 365;
const DAY_IN_MS = 24 * 60 * 60 * 1000;

// ─────────────────────────────────────────────────────────────────────────────
// 유틸리티 함수
// ─────────────────────────────────────────────────────────────────────────────

function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function getCookie(name: string): string | null {
  if (!browser) return null;
  const regex = new RegExp(`(?:^|; )${escapeRegex(name)}=([^;]*)`);
  const match = document.cookie.match(regex);
  return match ? decodeURIComponent(match[1]) : null;
}

function setCookie(name: string, value: string | number, days = DEFAULT_COOKIE_DAYS): void {
  if (!browser) return;

  const date = new Date(); // eslint-disable-line svelte/prefer-svelte-reactivity
  date.setTime(date.getTime() + days * DAY_IN_MS);
  const expires = `; expires=${date.toUTCString()}`;
  const secure = location.protocol === 'https:' ? '; Secure' : '';

  // biome-ignore lint/suspicious/noDocumentCookie: 상태 영속화 필수 로직
  document.cookie = `${name}=${encodeURIComponent(value)}${expires}; path=/; SameSite=Lax${secure}`;
}

// ─────────────────────────────────────────────────────────────────────────────
// 메인 함수
// ─────────────────────────────────────────────────────────────────────────────

export function createPersistedState<T extends string | number>(
  key: string,
  initial: T,
  allowedValues?: readonly T[],
  domUpdater?: (value: T) => void
) {
  let current = $state<T>(initial);

  // 값 유효성 검증
  const isValid = (val: unknown): val is T =>
    val != null && (allowedValues ? (allowedValues as readonly unknown[]).includes(val) : true);

  // camelCase → kebab-case 변환
  const attrKey = `data-${key.replace(/([A-Z])/g, '-$1').toLowerCase()}`;

  // DOM 및 쿠키 동기화
  function updateDom(value: T): void {
    if (!browser) return;

    if (domUpdater) {
      domUpdater(value);
    } else {
      document.documentElement.setAttribute(attrKey, String(value));
    }
    setCookie(key, value);
  }

  // 값 파싱 및 검증 헬퍼
  function parseAndValidate(rawValue: string | null): T | null {
    if (rawValue === null || rawValue === '') return null;

    let parsed: unknown = rawValue;

    if (typeof initial === 'number') {
      const num = Number(rawValue);
      // 빈 문자열이나 숫자가 아닌 경우 제외
      if (Number.isNaN(num)) return null;
      parsed = num;
    }

    return isValid(parsed) ? (parsed as T) : null;
  }

  // 초기값 로드 (SSR data-* → 쿠키 → 기본값)
  function init(): void {
    if (!browser) return;

    // 1) SSR이 심어둔 data-* 우선 (가장 신뢰도 높음)
    const fromDom = parseAndValidate(document.documentElement.getAttribute(attrKey));
    if (fromDom !== null) {
      current = fromDom;
      // 주의: DOM에서 가져왔으므로 쿠키가 만료되었거나 없을 수 있음.
      // 쿠키를 갱신하여 수명을 연장해주는 것이 좋습니다.
      setCookie(key, fromDom);
      return;
    }

    // 2) 쿠키 Fallback
    const fromCookie = parseAndValidate(getCookie(key));
    if (fromCookie !== null) {
      current = fromCookie;
      // 쿠키에는 있지만 DOM에는 반영 안 된 상태이므로 DOM 업데이트 필요
      // (예: JS로만 렌더링된 페이지, 혹은 첫 방문이라 SSR 속성이 없을 때)
      if (!domUpdater) {
          document.documentElement.setAttribute(attrKey, String(fromCookie));
      } else {
          domUpdater(fromCookie);
      }
      return;
    }

    // 3) 기본값 (아무것도 없을 때)
    current = initial;
    updateDom(initial);
  }

  // 값 설정
  function set(value: T): void {
    if (!isValid(value)) return;
    current = value;
    updateDom(value);
  }

  return {
    get current() {
      return current;
    },
    init,
    set
  };
}
```

### 변경된 핵심 로직 설명

1.  **`parseAndValidate` 함수 도입**:
    기존에 `init` 함수 내에 분산되어 있던 `Number` 변환, `NaN` 체크, `isValid` 호출 로직을 하나의 함수로 통합했습니다. 이를 통해 DOM 속성을 읽을 때와 쿠키를 읽을 때의 로직이 완전히 동일함을 보장하고 코드를 간결하게 만들었습니다.

2.  **쿠키 갱신 로직 추가 (`init` 1번 케이스)**:
    DOM(`data-*`)에서 값을 성공적으로 읽어왔더라도, `setCookie(key, fromDom)`를 호출하도록 변경했습니다. 이는 사용자가 사이트를 계속 이용 중이라면 쿠키 만료 기한을 다시 365일 뒤로 연장해주기 위함입니다(Keep-alive 효과).

3.  **DOM 업데이트 최적화**:
    쿠키에서 값을 읽어왔을 때(`fromCookie`)는 `updateDom` 전체를 호출하는 대신, 필요한 DOM 속성 업데이트만 수행하도록 분리했습니다(혹은 `domUpdater` 호출). `setCookie`를 중복 호출하는 비용을 줄입니다.
