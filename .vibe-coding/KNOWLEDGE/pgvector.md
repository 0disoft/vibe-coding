# pgvector 0.8.x 업데이트 핵심 정리

(기준: 2024-11-13 \~ 2025-12-03)

## 1. 기간 내 릴리스 요약

질문 범위에 포함되는 버전은 0.8.1 하나다. 하지만 실제 시스템 설계에 영향을 미치는 건 0.8.0이므로 두 버전을 함께 봐야 한다.

| 날짜 (UTC) | 버전 | 상태 | 핵심 요약 |
| :--- | :--- | :--- | :--- |
| 2025-09-04 | 0.8.1 | 기간 내 포함 | Postgres 18 rc1 지원, binary\_quantize 성능 최적화 |
| 2024-10-30 | 0.8.0 | 직전 버전 | iterative index scan 도입, 배열의 sparsevec 변환 지원, Postgres 12 지원 종료 |

## 2. 0.8.1: 호환성과 미세 조정

이 버전은 새로운 기능 추가나 사용법 변경이 없다. 개발자는 딱 두 가지만 체크하면 된다.

1. Postgres 18을 도입할 계획이 있는가?
2. 이진 양자화 인덱스를 사용 중인가?

위 사항에 해당하지 않는다면 코드 변경 없이 버전만 올려도 무방하다.

### 주요 변경점

- 호환성: Postgres 18 rc1 빌드 및 실행을 공식 지원한다.
- 성능: binary\_quantize 함수 로직이 개선되어 해당 인덱스를 타는 쿼리 속도가 빨라졌다.

### 코드 영향

애플리케이션 로직이나 SQL 문법은 기존과 100% 동일하다. 인덱스 정의도 그대로 유지하면 된다.

```sql
-- 이진 양자화 인덱스 예시
-- 0.8.1 업데이트 후에도 이 DDL은 변경할 필요가 없습니다.
CREATE INDEX ON items
USING hnsw ((binary_quantize(embedding)::bit(3)) bit_hamming_ops);
```

## 3. 0.8.0: 실전 설계를 바꾸는 메이저 변화

실질적인 기능 변화는 여기에 다 있다. 기존 0.7.x 버전을 쓰고 있다면 반드시 숙지해야 할 내용이다.

### 3.1 Postgres 12 지원 공식 종료

가장 중요한 비호환 변경 사항이다.

- 내용: 0.8.0부터 Postgres 12를 더 이상 지원하지 않는다.
- 대응: 현재 운영 중인 DB가 Postgres 12라면 pgvector를 0.7.4 버전에 고정해야 한다. 0.8.x 기능을 쓰려면 DB 엔진을 최소 13 이상으로 업그레이드하는 것이 우선이다.

### 3.2 Iterative Index Scan 도입

필터 조건이 걸린 근사 이웃 검색 쿼리의 품질을 높이는 기능이다. HNSW나 IVFFlat 인덱스가 설정된 개수만큼만 찾고 멈추는 것이 아니라, 조건을 만족하는 행을 찾을 때까지 인덱스를 더 뒤지는 방식이다.

- strict\_order: 거리 순서를 엄격하게 지키며 탐색한다. 정확도가 중요할 때 쓴다.
- relaxed\_order: 순서가 약간 뒤섞이더라도 리콜 확보를 최우선으로 한다.

<!-- end list -->

```sql
-- 1. 세션 레벨에서 반복 스캔 설정 튜닝
-- 순서 정확도를 약간 희생하더라도 결과 집합(Recall)을 최대한 확보하는 모드입니다.
SET hnsw.iterative_scan = 'relaxed_order';

-- 인덱스 스캔 시 탐색할 튜플의 최대 개수를 제한하여 성능 저하를 방지합니다.
SET hnsw.max_scan_tuples = 20000;

-- 2. 필터가 포함된 ANN 쿼리 실행
-- 카테고리 필터 때문에 검색 결과가 부족해지는 현상을 방지할 수 있습니다.
SELECT id, title, embedding <=> $1::vector AS distance
FROM products
WHERE category IN ('electronics', 'smart-home')
ORDER BY distance
LIMIT 100;
```

### 3.3 배열 및 기존 벡터의 Sparsevec 변환

희소 벡터를 다루기가 훨씬 편해졌다. 이전에는 텍스트로 변환해서 넣어야 했지만, 이제는 배열이나 일반 벡터에서 바로 캐스팅할 수 있다.

- array\_to\_sparsevec
- vector\_to\_sparsevec

이 기능 덕분에 0이 많은 데이터를 굳이 무거운 dense vector로 저장할 필요가 없어졌다.

```sql
-- 실수 배열을 희소 벡터(sparsevec)로 변환하여 저장하는 예시
INSERT INTO document_vectors (features)
SELECT array_to_sparsevec(
  -- 대부분의 값이 0인 데이터 배열입니다.
  ARRAY[0, 0.8, 0, 0.5, 0, 0.9, 0, 0, 0, 0],
  -- 전체 차원 수 (여기서는 10차원)
  10,
  -- 0인 값을 제외할지 여부 (false면 0도 포함하지만, 보통 true로 씁니다)
  FALSE
);
```

### 3.4 비용 추정 및 성능 개선

옵티마이저가 인덱스를 탈지 말지 결정하는 비용 계산 로직이 정교해졌다. 필터가 복잡하게 걸린 쿼리에서 실행 계획이 더 효율적으로 잡힐 가능성이 높다.

## 4. 최종 체크리스트

업데이트 전 다음 세 가지를 확인해라.

1. **DB 버전 확인:** Postgres 12를 쓰고 있다면 업그레이드 전까지 pgvector 업데이트 금지.
2. **필터 쿼리 점검:** WHERE 절이 포함된 벡터 검색이 많다면 0.8.x 업그레이드 후 `iterative_scan` 옵션을 켜서 검색 품질(Recall)이 개선되는지 테스트한다.
3. **데이터 구조 최적화:** 0이 많은 벡터 데이터를 다룬다면 `sparsevec`으로 스키마 변경을 고려해 저장 용량을 아낀다.
