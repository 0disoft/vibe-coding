# SQLite v3.47 - v3.51 아키텍처 리포트: 안정성과 JSONB의 진화

2024년 말부터 2025년 말까지 SQLite의 변화는 **'JSON 처리 능력의 고도화'**와 **'보안/운영 제어권 강화'**로 요약됩니다. 데이터베이스 엔진 자체의 안정성을 높이면서, 현대적 애플리케이션 요구사항인 JSON 데이터 처리와 클라우드/임베디드 환경에서의 제어 기능을 대폭 강화했습니다.

본 리포트는 해당 기간의 릴리스를 분석하여, 실무에서 즉시 적용 가능한 아키텍처 전략과 마이그레이션 포인트를 제시합니다.

---

## 1. Executive Summary: 버전별 핵심 아키텍처 변화

| 버전        | 릴리즈 시기 | 핵심 아키텍처 변화 (Architecture Shift)                                                                                           |
| :---------- | :---------- | :-------------------------------------------------------------------------------------------------------------------------------- |
| **v3.48.0** | '25.01      | **Flexibility:** `iif()`/`if()` 등 SQL 함수 유연성 확대 및 사용자 정의 함수 제한(127→1000) 대폭 완화.                             |
| **v3.49.0** | '25.02      | **Control:** `ATTACH` 구문에 대한 세밀한 제어 권한(`ENABLE_ATTACH_*`) 도입으로 멀티 테넌트 환경 보안 강화.                        |
| **v3.50.0** | '25.05      | **Concurrency:** `sqlite3_setlk_timeout()`을 통해 락 대기 정책을 비즈니스 로직과 분리하여 운영 안정성 확보.                       |
| **v3.51.0** | '25.11      | **Data Modeling:** `jsonb_each()`, `jsonb_tree()` 도입으로 비정형 데이터(JSON)를 정형 데이터처럼 관계형으로 처리하는 능력 극대화. |

---

## 2. Critical Action Items: 마이그레이션 필수 점검

### 2-1. JSON 데이터 처리 전략 (v3.50.2, v3.51.0)

- **JSON5 파싱 강화:** v3.50.2부터 JSON5 입력값 검증이 엄격해졌습니다. 비표준 JSON 포맷을 데이터베이스에 저장하던 로직이 있다면, 사전 정제(Sanitization) 과정을 추가해야 합니다.
- **JSONB 테이블 함수 활용:** v3.51.0의 `jsonb_each()`와 `jsonb_tree()`는 JSON 데이터를 별도 인덱싱 없이 관계형으로 쿼리할 수 있게 해줍니다. 복잡한 JSON 파싱 로직을 애플리케이션에서 DB 레벨로 이관하여(ETL Pushdown) 성능과 유지보수성을 높이십시오.

### 2-2. 보안 및 운영 제어 (v3.49.0, v3.50.0)

- **ATTACH 제한:** SaaS나 플러그인 아키텍처에서 SQLite를 사용한다면, `SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE=0` 설정을 통해 임의의 DB 파일 생성을 원천 차단하십시오. 이는 파일 시스템 레벨의 보안 위험을 제거하는 강력한 수단입니다.
- **Lock Timeout 분리:** v3.50.0의 `sqlite3_setlk_timeout()`을 활용하여, 일반적인 Busy Timeout과 파일 락 대기 시간을 분리하십시오. 사용자 트래픽 처리와 백그라운드 관리 작업(Backup, Vacuum) 간의 우선순위를 명확히 할 수 있습니다.

### 2-3. 레거시 제거 (v3.48.0)

- **User Authentication 삭제:** `SQLITE_USER_AUTHENTICATION` 확장 기능이 완전히 제거되었습니다. DB 파일 자체에 로그인을 의존하던 레거시 시스템은 애플리케이션 레벨 인증이나 OS 파일 권한 관리로 설계를 변경해야 합니다.

---

## 3. Strategic Adoption: 도입해야 할 신규 패턴

### 3-1. 조건부 로직의 SQL 이관

`iif()` (또는 `if()`) 함수의 인자 제한이 해제되고 가독성이 개선되었습니다. 복잡한 `CASE WHEN` 구문을 `iif()`로 리팩토링하여 쿼리의 가독성을 높이고, 애플리케이션 로직을 간소화하십시오.

### 3-2. 안전한 데이터 교환

바이너리 데이터를 SQL 덤프나 로그로 남겨야 한다면 v3.50.0의 `unistr()` 및 `unistr_quote()` 함수를 사용하십시오. 이스케이프 처리를 DB 엔진에 위임함으로써 인젝션 공격이나 데이터 손상 위험을 최소화할 수 있습니다.

---

## 4. Conclusion

SQLite v3.47~3.51 구간은 "더 안전하고, 더 강력한 JSON 엔진"으로의 진화를 보여줍니다. 기존 시스템의 안정성을 위해 최신 패치 버전(v3.50.4 이상)으로 업그레이드하는 것을 기본으로 하되, **JSONB 기능과 ATTACH 제어 옵션**을 적극 활용하여 데이터 아키텍처를 현대화하십시오.
