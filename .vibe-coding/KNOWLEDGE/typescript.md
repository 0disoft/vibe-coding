# TypeScript 5.7 ~ 5.9 주요 변경 사항

먼저 결론부터 말하면, 질문한 기간에 정식으로 나온 TypeScript 릴리스는 3개야.

* 5.7 (2024-11-21 최종)
* 5.8 (2025-02-25 최종)
* 5.9 (2025-07-22 최종)

그 전에 나온 5.6 최종 릴리스 날짜가 2024-09-09라서, 네가 지정한 시작일(9월 13일) 바로 직전에 이미 나와 있는 상태였고, 그래서 이번 표에는 포함 안 했어. 대신 "이전 버전에서 이미 깔려 있던 변화" 정도로만 잠깐 언급하겠다.

아래에서

1. 기간 내에 나온 버전과 날짜를 한 번에 보고
2. 버전별로 "실제 코딩할 때 꼭 알아야 할 것들"만 추려볼게.

## 1. 2024-09-13 ~ 2025-12-08 사이 TS 릴리스 요약

날짜는 TypeScript 공식 iteration plan 이슈의 "Final Release" 기준이야.

| 버전 | 최종 릴리스 날짜 | 주요 초점 |
| --- | --- | --- |
| 5.7 | 2024-11-21 | 초기화되지 않은 변수 검사 강화, import 경로 재작성 옵션, ES2024 타깃 추가 등 |
| 5.8 | 2025-02-25 | `return` 안에서 분기별 타입체크 강화, Node와 호환되는 `--erasableSyntaxOnly`, 새 Node 모듈 옵션 등 |
| 5.9 | 2025-07-22 | `tsc --init` 기본값 대개 새로 설계, `node20` 모듈 해석, 6.0 대비 deprecation 플랜 시작 |

## 2. 버전별로 "실제 코딩에 영향 주는 것"만 정리

버전마다 표를 따로 둘게.
각 표에서

* 구분: 대략적인 영역
* 내용: 뭐가 바뀌었는지
* 왜 중요한가: 실제로 너 코드에 어떻게 영향을 줄 수 있는지
* 어떻게 대응할까: 지금 프로젝트에서 취할 액션

형식으로 정리했어.

### 2.1 TypeScript 5.7 (2024-11-21)

| 구분 | 내용 | 왜 중요한가 | 어떻게 대응할까 |
| --- | --- | --- | --- |
| 타입 검사 강화 | "절대로 초기화되지 않은 변수"에 대한 새로운 에러. 함수 안에서 `let result: number;`만 선언해 두고, 실제로는 어떤 코드 경로에서도 할당이 안 되는데, 나중에 내부 중첩 함수에서 그 값을 쓰면 이제 에러가 뜬다. | 예전에는 "어쩌다 운 좋게 안 터지던 버그"가 조용히 넘어갔는데, 5.7부터는 컴파일 타임에 잡힌다. 기존 코드가 갑자기 빨간 줄로 뒤덮일 수 있다는 뜻. | 새 버전으로 올릴 때 `Variable 'x' is used before being assigned` 류 에러가 늘어난다면, "어느 경로에서도 값이 안 들어가는 로컬 변수"가 있는지 먼저 찾고, 필요하면 초기값을 주거나 제어 흐름을 단순화해. 중첩 함수 안에서 외부 변수 참조하는 패턴이 특히 의심 포인트. |
| 빌드 출력 경로 재작성 | `--rewriteRelativeImportExtensions` 옵션 추가. TS를 "그 자리에서" 실행하는 도구들(ts-node, tsx, Deno, Bun, Node `--experimental-strip-types`)과 같이 쓸 때, 소스 상에서는 `import "./foo.ts"`로 적고, 출력되는 JS에서는 `./foo.js` 같은 식으로 확장자를 자동으로 바꿔 준다. | SvelteKit + Bun 같이 "ESM + 실제 런타임에서 .js 확장자 요구" 환경에서, import 경로 관리가 엄청 귀찮았는데, 이 플래그로 해결 가능. 잘못 맞춰두면 런타임에서 `ERR_MODULE_NOT_FOUND`가 터진다. | 지금까지 번들러로만 돌렸다면 당장은 영향이 없을 수도 있다. 다만 `ts-node`나 `tsx`로 직접 실행하는 스크립트가 있다면, tsconfig에 `rewriteRelativeImportExtensions: true`를 추가하고, import 경로를 `.ts` 기준으로 통일해 두는 걸 추천. |
| 새 타깃 `es2024` | `--target es2024` 추가. ES 표준의 최신 기능을 타깃으로 빌드할 수 있다. | Node 20 이상이나 최신 브라우저를 타깃으로 한다면, 굳이 다운레벨 트랜스파일 안 해도 되는 영역이 더 넓어진다. 반대로 구형 환경 지원 범위를 잘못 판단하면 런타임에서 미지원 문법이 나올 수 있다. | 런타임 환경이 충분히 새거라면, 신규 프로젝트의 기본 타깃 후보를 `es2022 → es2024`로 올려도 된다. 다만 polyfill 전략과 브라우저 지원 범위를 먼저 정하고 움직이는 게 안전. |
| Node 22 V8 compile cache | Node 22에서 V8 compile cache를 활용해 TypeScript 실행 속도를 개선하는 옵션 지원. | 런타임 성능보다는 "개발 중 서버 재시작 속도" 같은 체감에 영향을 준다. 코드 의미는 안 바뀌지만, 느려서 피했던 타입체크를 다시 켤 여유가 생길 수 있다. | Bun 기준으로는 직접적인 영향은 적지만, Node 22를 기반으로 하는 도구(ts-node 최신 버전 등)를 쓴다면 `--enable-source-maps`와 같이 설정을 정리하면서 활용 여부를 검토. |

요약하면, 5.7은 "타입 검사 강도 업 + Node/런타임 호환성 옵션 추가"가 핵심이다.
특히 never-initialized 체크랑 `--rewriteRelativeImportExtensions`는, SvelteKit + Bun처럼 ESM를 직접 쓰는 너한테 꽤 체감이 클 수 있는 부분.

### 2.2 TypeScript 5.8 (2025-02-25)

| 구분 | 내용 | 왜 중요한가 | 어떻게 대응할까 |
| --- | --- | --- | --- |
| `return` 분기별 타입 체크 | `return cond ? a : b` 같은 삼항 연산자가 있을 때, 이제는 통째로 `a \| b`를 보고만 판단하는 게 아니라, 각 분기마다 함수의 선언된 반환 타입에 맞는지 따로 확인한다. 예시로, 캐시에 `any`가 섞인 코드에서 잘못된 타입을 리턴하면 바로 에러로 잡힌다. | "any가 섞여서 타입 시스템이 포기하던 구간"에서 디테일하게 버그를 잡는다. 기존 코드가 새로 에러를 뿜어낼 수 있지만, 대부분 진짜 버그거나 설계가 모호했던 부분일 가능성이 크다. | 에러가 터지는 함수는 보통 "캐시나 외부 입력에서 값을 꺼내서 가공하는" 부분일 확률이 높다. 반환 타입을 좀 더 정확히 선언하고, 분기마다 `as 타입`으로 찍어 누르기보다, 중간 변수로 나누고 `if` 분기를 명시적으로 써 주는 게 장기적으로 안전. |
| `--erasableSyntaxOnly` 플래그 | 이 플래그를 켜면 "타입 정보만 지우고 나머지 코드는 그대로 두는" 식으로만 동작할 수 있는 코드만 허용한다. 즉, `enum`, `namespace`처럼 JS 코드를 실제로 생성하는 TS 전용 기능을 쓰면 에러가 난다. Node의 `--experimental-strip-types` 같은 단순 타입 제거 도구와 호환되도록 강제하는 모드다. | 앞으로 Node 생태계가 "TS 코드를 별도 트랜스파일 없이, 타입만 제거해서 실행"하는 방향으로 가고 있어서, 이런 제약 모드는 점점 중요해질 가능성이 높다. 지금부터 이 모드에 맞춰 코드를 짜면, 나중에 빌드 파이프라인을 크게 줄일 수 있다. | 새 프로젝트라면 tsconfig에 `erasableSyntaxOnly: true`를 검토해 볼 만하다. 그러면 자연스럽게 `enum`이나 `namespace` 대신 `const enum` 리터럴, 일반 객체, 모듈 시스템을 쓰게 되고, 런타임 코드와 타입 시스템의 경계가 더 깨끗해진다. |
| 새 모듈 옵션 `--module node18`·`node20` | iteration plan에 명시된 것처럼, Node 18, 20 환경에 맞춘 `module` 값이 추가됐다. 이는 ESM과 CJS가 뒤섞인 현실 Node 프로젝트에서, 해석 규칙과 lib 타입을 더 정확히 맞추기 위한 시도다. | 지금까지는 `module: nodenext` 같은 느슨한 설정을 쓰면서 직접 ts-node나 번들러가 나머지를 메꿔 줬다. 버전별 표준이 잡히면, "Node 20 이상만 지원한다" 같은 선언을 tsconfig에서 더 명시적으로 표현할 수 있다. | SvelteKit + Bun 조합이면 보통 번들러가 모듈 시스템을 책임지니까, 당장 이 옵션을 쓸 필요는 없다. 다만 서버 코드(예를 들어 순수 Node 스크립트)를 따로 운영한다면, 그 tsconfig에서 `module: node20` 같은 값으로 명확히 못을 박아 주는 게 좋다. |
| `lib.d.ts` 업데이트와 새로운 JS 기능 | 5.8 iteration plan에는 `lib.d.ts` 업데이트가 포함돼 있고, 공식 lib 이슈에서도 5.8용 타입 업데이트가 진행됐다. | 이 말은 곧 최신 브라우저와 Node에 들어간 JS·DOM 기능이 타입 레벨에서 더 잘 지원된다는 뜻이다. 반대로, 브라우저 지원 범위보다 앞선 기능을 타입이 허용하고 있을 수도 있어서, "타입이 되니까 실제 런타임도 되겠지"라고 가정하면 안 된다. | 새로운 표준 API를 쓸 때는 "런타임 지원표"를 먼저 보고, 그 다음에 타입이 따라왔는지 확인하는 순서를 유지해. 타입이 된다고 바로 쓰기보다는, 폴리필 여부와 브라우저 매트릭스를 먼저 보는 습관이 필요하다. |

5.8은 한 줄로 요약하면

* `return` 안 분기까지 깊게 파고드는 타입 체커
* "타입만 지우는" 스타일의 빌드 파이프라인을 위한 안전 모드

이 두 가지가 핵심이다.
Node 쪽으로 더 밀고 갈 생각이 있다면, `--erasableSyntaxOnly`를 기준으로 프로젝트를 설계해 보는 게 장기적으로 의미 있을 거야.

### 2.3 TypeScript 5.9 (2025-07-22)

| 구분 | 내용 | 왜 중요한가 | 어떻게 대응할까 |
| --- | --- | --- | --- |
| `tsc --init` 기본값 재설계 | `tsc --init`가 예전처럼 주석 달린 거대한 `tsconfig.json`을 만드는 대신, 훨씬 미니멀한 설정을 생성한다. 동시에 몇 가지 권장 설정을 기본값으로 포함한다. 예를 들면 모듈로 간주하는 파일을 강제하기 위한 `moduleDetection`, 최근 런타임을 가정하는 `target: esnext`, JSX 프로젝트에 맞춘 기본 `jsx` 옵션, 불필요한 `@types` 로딩을 막기 위한 빈 `types` 배열 등이 들어간다. | "새 프로젝트 시작할 때 tsc --init 한 번 돌려두고, 나머지는 IDE 자동완성으로 옵션 채운다"는 현실 사용 패턴에 맞게 설계된 변화다. 중요한 건, 이제부터 튜토리얼이나 블로그의 `tsconfig` 예시가 전부 이 새로운 기본값을 전제로 쓰이기 시작한다는 점. | 이미 SvelteKit 템플릿이 자체 tsconfig를 들고 있으니까, 직접 `tsc --init`을 많이 쓰지는 않을 것이다. 대신, 새로 작성하는 라이브러리나 Node 스크립트용 레포에서 `tsc --init`으로 생성된 파일을 그대로 커밋하면 "예전 프로젝트와 설정 스타일이 꽤 다르게 생겼다"는 걸 감안하고, 조직 내 가이드를 맞춰 두는 게 좋다. |
| `moduleResolution: node20` 추가 | iteration plan에 `node20 Resolution` 작업이 포함돼 있고, 5.9에서 Node 20에 맞는 모듈 해석 모드가 도입된다. | ESM/CJS 혼합, `exports`/`imports` 필드, 조건부 exports 등 Node 20까지 축적된 규칙을 더 정확히 반영한다. 잘못된 모듈 해석 때문에 생기던 "로컬에선 되는데 배포하면 안 되는" 류 문제를 줄이는 게 목표다. | Node 20 이상만 지원한다면, 서버 코드용 tsconfig에서 `moduleResolution: node20`을 고려해 볼 만하다. 반대로, 레거시 환경까지 넓게 지원해야 한다면, 새 모드로 옮기기 전에 CI에서 모듈 로딩 테스트를 충분히 돌려볼 것. |
| 6.0 대비 deprecation 플랜 시작 | 5.9 iteration plan에 `6.0 Deprecation Plans`가 포함돼 있다. 즉, 6.0에서 실제로 제거·변경될 기능에 대해, 5.9부터는 경고나 deprecation 메시지를 띄우는 작업을 시작한다는 뜻이다. | 앞으로 나올 6.0은 내부 구현이 크게 바뀌고 일부 오래된 옵션이나 조합이 사라질 예정이라, 5.9 시점부터 "미리 경고를 보고 옮길 시간"을 주는 구조다. 정확히 어떤 옵션이 대상인지는 공식 release notes 전체를 봐야 알 수 있지만, 대체로 매우 옛날 JS 타깃이나 레거시 모듈 시스템 관련 설정이 중심이다. | 5.9로 올린 뒤 tsconfig 관련 경고가 보이기 시작하면 "이건 6.0에서 없어질 준비를 하는 것"이라는 신호라고 보면 된다. 경고 메시지에 대체 설정이 같이 제안되는 경우가 대부분이니, 그 제안에 맞춰 조금씩 설정을 옮겨 두는 게 안전하다. |
| 네이티브 포트 준비 작업 | iteration plan에 `Port to Native` 작업이 포함돼 있다. 이는 이후 7.0에서 예정된 네이티브(Go 기반) 컴파일러로 넘어가기 위한 발판이다. | 이 부분은 주로 성능과 내부 구조에 관한 거라, "실제 코드 의미"는 바뀌지 않는 것이 목표다. 다만 매우 마이너한 버그나, 이상한 모듈 조합에서 동작이 살짝 달라질 여지는 있다. | 여기서는 "알고만 있다" 정도면 충분하다. 7.0 시점에 본격적인 마이그레이션 가이드가 나올 테니, 5.9에서는 성능·경고 메시지 정도만 관찰하면서, 이상 동작이 있는지 회귀 테스트를 강화하는 정도로 대응하면 된다. |

5.9는 요약하면

* "새 프로젝트 시작용 tsconfig 템플릿을 갈아엎은 버전"
* "6.0, 7.0으로 가는 징검다리"

라고 보면 된다.
SvelteKit 템플릿처럼 프레임워크에서 tsconfig를 관리해 주는 프로젝트는 체감 변화가 작고, 반대로 라이브러리 레포나 Node 스크립트 레포에서는 꽤 큼직하게 영향을 받는 편.

## 3. "이 버전들로 지금 올릴 때" 현실적인 체크리스트

질문은 버전별로 "무엇이 바뀌었는가"였지만, 실제로는 "그럼 내 레포에서 뭘 바꿔야 하나"가 더 중요하니까, 마지막으로 짧게 요약해 볼게.

1. 5.7로 올릴 때
   * 새로 생기는 `Variable 'x' is used before being assigned` 에러들을 전부 훑어서
     * 진짜 버그인지
     * 아니면 타입 설계/제어 흐름을 정리해야 하는지
       를 한 번에 정리한다.
   * Node나 ts-node를 직접 쓰는 스크립트가 있다면, `rewriteRelativeImportExtensions` 도입을 검토한다.

2. 5.8로 올릴 때
   * `return cond ? a : b` 패턴이 많은 함수들에서 새로운 타입 에러가 나오는지 확인한다.
   * 새 프로젝트라면 `--erasableSyntaxOnly`를 기본으로 두고, enum/namespace 대신 "순수 JS + 타입" 조합으로만 코드를 짤지 전략을 정한다.

3. 5.9로 올릴 때
   * `tsc --init`으로 새 tsconfig를 만드는 레포와, 기존 스타일을 유지할 레포를 구분해 둔다.
   * `moduleResolution: node20` 도입 여부를 Node 서버 코드 기준으로 검토한다.
   * tsconfig에서 deprecation 경고가 뜨는 옵션들을 체크하고, 6.0이 나오기 전에 조금씩 대체 옵션으로 이동한다.
